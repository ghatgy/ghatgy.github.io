<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="PHP基本语法规则"><meta name="keywords" content=""><meta name="author" content="ghatgy"><meta name="copyright" content="ghatgy"><meta name="theme-color" content="#0078E7"><title>PHP基本语法规则 | Hexo</title><link rel="shortcut icon" href="/yun-favicon.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    let Yun = window.Yun || {};
    let CONFIG = {"root":"/","title":"诗酒年华的小站","version":"0.4.0","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><script src="//at.alicdn.com/t/font_1140697_pa6cswvjpq.js" async></script><meta name="generator" content="Hexo 4.2.0"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle sidebar-toggle-fixed hty-icon-button"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><aside class="sidebar"><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc sidebar-nav-active hty-icon-button" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about" title="ghatgy"><img loading="lazy" src="/avatar.jpg" alt="ghatgy"></a><div class="site-author-name"><a href="/about">ghatgy</a></div><a class="site-name" href="/about/site.html">Hexo</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item site-state-posts"><a href="/archives" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">15</span></a></div><a class="site-state-item hty-icon-button" href="https://github.com/YunYouJun/yunyoujun.github.io/issues/96" target="_blank" rel="noopener" title="reward.comment"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ghatgy" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.popiask.cn/" title="POPI" target="_blank" style="color:#525252"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-questionnaire-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.jsdelivr.net/" title="微信公众号" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/" title="Telegram" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-fill"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.now.sh/" title="Travelling" target="_blank" style="color:black"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-send-plane-2-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div></div><script defer src="/js/sidebar.js"></script><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-progress"><div class="progress-bar"></div><div class="progress-info"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span></div></div><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PHP基本语法规则"><span class="toc-number">1.</span> <span class="toc-text">PHP基本语法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP-标记"><span class="toc-number">1.1.</span> <span class="toc-text">PHP 标记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP-语句结束符"><span class="toc-number">1.2.</span> <span class="toc-text">PHP 语句结束符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP注释"><span class="toc-number">1.3.</span> <span class="toc-text">PHP注释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#变量"><span class="toc-number">2.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#含义与定义形式"><span class="toc-number">2.1.</span> <span class="toc-text">含义与定义形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的命名规则"><span class="toc-number">2.2.</span> <span class="toc-text">变量的命名规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的4种基本操作"><span class="toc-number">2.3.</span> <span class="toc-text">变量的4种基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量传值（难点）"><span class="toc-number">2.4.</span> <span class="toc-text">&#x3D;&#x3D;变量传值（难点）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预定义变量"><span class="toc-number">2.5.</span> <span class="toc-text">&#x3D;&#x3D;预定义变量&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GET变量"><span class="toc-number">2.5.1.</span> <span class="toc-text">$_GET变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST"><span class="toc-number">2.5.2.</span> <span class="toc-text">$_POST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REQUEST"><span class="toc-number">2.5.3.</span> <span class="toc-text">$_REQUEST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SERVER变量"><span class="toc-number">2.5.4.</span> <span class="toc-text">$_SERVER变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可变变量"><span class="toc-number">2.6.</span> <span class="toc-text">可变变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量"><span class="toc-number">3.</span> <span class="toc-text">常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常量的两种定义形式"><span class="toc-number">3.1.</span> <span class="toc-text">常量的两种定义形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量的两种取值形式"><span class="toc-number">3.2.</span> <span class="toc-text">常量的两种取值形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量与常量的区别："><span class="toc-number">3.3.</span> <span class="toc-text">变量与常量的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断一个常量是否存在：defined"><span class="toc-number">3.4.</span> <span class="toc-text">判断一个常量是否存在：defined();</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预定义常量"><span class="toc-number">3.5.</span> <span class="toc-text">预定义常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几个魔术常量"><span class="toc-number">3.6.</span> <span class="toc-text">几个魔术常量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据类型"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型分类与概述"><span class="toc-number">4.1.</span> <span class="toc-text">数据类型分类与概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整型integer，int"><span class="toc-number">4.2.</span> <span class="toc-text">整型integer，int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浮点型float"><span class="toc-number">4.3.</span> <span class="toc-text">浮点型float</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#布尔型Boolean"><span class="toc-number">4.4.</span> <span class="toc-text">布尔型Boolean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串型String"><span class="toc-number">4.5.</span> <span class="toc-text">字符串型String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组类型Array"><span class="toc-number">4.6.</span> <span class="toc-text">数组类型Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空类型NULL"><span class="toc-number">4.7.</span> <span class="toc-text">空类型NULL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型判断"><span class="toc-number">4.8.</span> <span class="toc-text">类型判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型转换"><span class="toc-number">4.9.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运算符详解"><span class="toc-number">5.</span> <span class="toc-text">运算符详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#赋值运算符"><span class="toc-number">5.1.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算术运算符"><span class="toc-number">5.2.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连接运算符"><span class="toc-number">5.3.</span> <span class="toc-text">连接运算符( . )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自赋值运算符"><span class="toc-number">5.4.</span> <span class="toc-text">自赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自操作-自加自减）运算符"><span class="toc-number">5.5.</span> <span class="toc-text">自操作(自加自减）运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#比较运算符"><span class="toc-number">5.6.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逻辑运算符"><span class="toc-number">5.7.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条件运算符"><span class="toc-number">5.8.</span> <span class="toc-text">条件运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位运算符（了解）"><span class="toc-number">5.9.</span> <span class="toc-text">位运算符（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误抑制符"><span class="toc-number">5.10.</span> <span class="toc-text">&#x3D;&#x3D;错误抑制符@&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符的优先级"><span class="toc-number">5.11.</span> <span class="toc-text">运算符的优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流程控制"><span class="toc-number">6.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#流程控制概述"><span class="toc-number">6.1.</span> <span class="toc-text">流程控制概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if语句"><span class="toc-number">6.2.</span> <span class="toc-text">if语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分支结构之switch分支语句（重点）"><span class="toc-number">6.3.</span> <span class="toc-text">分支结构之switch分支语句（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环结构之while循环语句"><span class="toc-number">6.4.</span> <span class="toc-text">循环结构之while循环语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环结构之do-while循环语句"><span class="toc-number">6.5.</span> <span class="toc-text">循环结构之do while循环语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环结构之for循环语句（重点-难点"><span class="toc-number">6.6.</span> <span class="toc-text">&#x3D;&#x3D;循环结构之for循环语句（重点&#x2F;难点)&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多重循环及案例"><span class="toc-number">6.7.</span> <span class="toc-text">多重循环及案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环的中断"><span class="toc-number">6.8.</span> <span class="toc-text">循环的中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">7.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的概念与作用"><span class="toc-number">7.1.</span> <span class="toc-text">函数的概念与作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的定义与调用"><span class="toc-number">7.2.</span> <span class="toc-text">函数的定义与调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数执行原理（重点-难点）"><span class="toc-number">7.3.</span> <span class="toc-text">&#x3D;&#x3D;函数执行原理（重点&#x2F;难点）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数参数"><span class="toc-number">7.4.</span> <span class="toc-text">&#x3D;&#x3D;函数参数&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数返回值（重点"><span class="toc-number">7.5.</span> <span class="toc-text">函数返回值（重点)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可变函数"><span class="toc-number">7.6.</span> <span class="toc-text">可变函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名函数"><span class="toc-number">7.7.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统常用函数介绍"><span class="toc-number">7.8.</span> <span class="toc-text">系统常用函数介绍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数相关"><span class="toc-number">8.</span> <span class="toc-text">函数相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的作用域问题"><span class="toc-number">8.1.</span> <span class="toc-text">变量的作用域问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归函数（重点-难点"><span class="toc-number">8.2.</span> <span class="toc-text">递归函数（重点&#x2F;难点)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件加载"><span class="toc-number">9.</span> <span class="toc-text">文件加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#文件加载的含义"><span class="toc-number">9.1.</span> <span class="toc-text">文件加载的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件加载的四种方式（重点"><span class="toc-number">9.2.</span> <span class="toc-text">&#x3D;&#x3D;文件加载的四种方式（重点)&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四种方式的区别"><span class="toc-number">9.3.</span> <span class="toc-text">四种方式的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">10.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#错误分类"><span class="toc-number">10.1.</span> <span class="toc-text">错误分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见错误代号（重点）"><span class="toc-number">10.2.</span> <span class="toc-text">常见错误代号（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误触发"><span class="toc-number">10.3.</span> <span class="toc-text">错误触发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误显示设置"><span class="toc-number">10.4.</span> <span class="toc-text">错误显示设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误日志设置"><span class="toc-number">10.5.</span> <span class="toc-text">错误日志设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义错误处理（重点-难点"><span class="toc-number">10.6.</span> <span class="toc-text">&#x3D;&#x3D;自定义错误处理（重点&#x2F;难点)&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串详解"><span class="toc-number">11.</span> <span class="toc-text">字符串详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4种不同形式的字符串"><span class="toc-number">11.1.</span> <span class="toc-text">4种不同形式的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转义字符"><span class="toc-number">11.2.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串的长度问题"><span class="toc-number">11.3.</span> <span class="toc-text">字符串的长度问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用字符串函数（重点"><span class="toc-number">11.4.</span> <span class="toc-text">常用字符串函数（重点)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组详解"><span class="toc-number">12.</span> <span class="toc-text">数组详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组的概念和定义"><span class="toc-number">12.1.</span> <span class="toc-text">数组的概念和定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组下标问题"><span class="toc-number">12.2.</span> <span class="toc-text">数组下标问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP数组的维数"><span class="toc-number">12.3.</span> <span class="toc-text">PHP数组的维数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组的遍历（重点）"><span class="toc-number">12.4.</span> <span class="toc-text">&#x3D;&#x3D;数组的遍历（重点）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用数组函数"><span class="toc-number">12.5.</span> <span class="toc-text">常用数组函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组排序算法（重点-难点）"><span class="toc-number">12.6.</span> <span class="toc-text">&#x3D;&#x3D;数组排序算法（重点&#x2F;难点）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组查找算法"><span class="toc-number">12.7.</span> <span class="toc-text">数组查找算法</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/28/PHP%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ghatgy"><meta itemprop="description" content="PHP基本语法规则"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">PHP基本语法规则</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2020-05-28 18:07:28" itemprop="dateCreated datePublished" datetime="2020-05-28T18:07:28+08:00">2020-05-28</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2020-05-27 20:49:44" itemprop="dateModified" datetime="2020-05-27T20:49:44+08:00">2020-05-27</time></span><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content post-markdown"><h1 id="PHP基本语法规则"><a href="#PHP基本语法规则" class="headerlink" title="PHP基本语法规则"></a><strong>PHP基本语法规则</strong></h1><h2 id="PHP-标记"><a href="#PHP-标记" class="headerlink" title="PHP 标记"></a>PHP 标记</h2><p>​        PHP语言，是一种可以嵌入到“html”代码中的后台处理语言（程序）有以下几种标记形式，只推荐第一种。</p>
<ol>
<li><p>==<strong><?php   php代码写在这里.....  ?></strong>==<br>这是推荐写法！</p>
</li>
<li><script  language="php" >  php代码写在这里.....  </script>
</li>
<li><?   php代码写在这里.....  ?>
<p>需要到php.ini中进行配置：short_open_tag = On            //默认为Off，表示不能用该形式。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<p>​    纯PHP代码：可以省略标记结尾符。</p>
<p>​    后面，我们会写很多“纯php代码文件”（里面没有任何html代码）。</p>
<p>​    </p>
<h2 id="PHP-语句结束符"><a href="#PHP-语句结束符" class="headerlink" title="PHP 语句结束符"></a>PHP 语句结束符</h2><p>使用英文分号（;）表示一条语句的结束。</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200526202055.png" alt="" loading="lazy"></p>
<h2 id="PHP注释"><a href="#PHP注释" class="headerlink" title="PHP注释"></a>PHP注释</h2><p><strong>单行注释：</strong><br>    两个斜杠： //斜杠后面的部分就是注释内容，PHP语言不会去处理它（不执行）</p>
<p><strong>多行注释：</strong><br>    形式：<br>    /*<br>    这是注释内容。。。<br>    可以写多行<br>    */</p>
<p>​    /* 当然写一行也是可以的 */</p>
<p>​    ==重要的事情是：注释是写程序的非常重要的因素和习惯！==</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="含义与定义形式"><a href="#含义与定义形式" class="headerlink" title="含义与定义形式"></a>含义与定义形式</h2><p>就是使用一个“标记符号”（标识符），来代表某个数据。</p>
<p>类比：</p>
<p>用一个名字（姓名），来代表某个人。</p>
<p>用一个身份证号码，来代表某个人。。。</p>
<p>用一个变量，就可以理解为“使用一个数据”。</p>
<p>既然是变量，就是该数据时可以改变的一种数据。</p>
<p>对应常量：就是一种不可以（不允许）改变的数据。</p>
<p>==定义形式： $变量名 = 具体的数据；==</p>
<p><strong>==特别注意：变量名区分大小写！！！！！！==</strong></p>
<p>举例：</p>
<p>​    $v1 = 123;                      ==//这里的等于号（=），不是数学上的等于（相等），而是“赋值”的意思==</p>
<p>​                                            ==//其本质含义是：将123这个数据，放到v1这个变量中去。==</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200526203549.png" alt="" loading="lazy"></p>
<p>变量的另一个角度理解：</p>
<p>​        变量是一个“容器”，是一个“盒子”，是一个可以存放数据的位置——内存空间。</p>
<p>也可以这样去理解：</p>
<p>​        内存（条）中分割出很多很多的小格子，每个格子都有一个编号地址（所谓内存地址）。</p>
<p>​        其中存储了数据的格子上有一定的标记名（变量名），并存放了对应的数据。</p>
<p>​        图示如下：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527083138.png" alt="" loading="lazy"></p>
<p>对应代码如下：</p>
<p>​        $a = 200;</p>
<p>​        $b = 100;</p>
<p>​        其中，==“0xA01”，“0xA02”代表内存地址==。内存地址其实是我们看不到的，由系统分配。</p>
<h2 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h2><p><strong>基本规则（明规则）</strong></p>
<p>​    就是给一个变量命名的时候，要遵循的规则。</p>
<ol>
<li><p>构成：字母、数字、下划线；</p>
</li>
<li><p>开头：字母或下划线；</p>
</li>
<li><p>注意：变量名不要跟系统中的“关键字”（即语法所用单词）重复——关键字不多，也就几十个。</p>
</li>
</ol>
<p><strong>行业规则（潜规则）</strong></p>
<p>​        通常，尽量将变量命名为“见名知意”。</p>
<p>​        尽量用更容易理解的单词（或拼音）去表示一个数据，很多时候可以使用“多个单词（拼音）”。</p>
<p>​        比如：</p>
<p>​            ChildAge,  YungerAge, ParentHouse, MyParentHouse, MyParentHousePrice</p>
<p>​        此时，通常有两个行业中的惯例规则：</p>
<p>​        骆驼命名法（小驼峰命名法）：第一个单词首字母小写，其余单词首字母大写。</p>
<p>​            childAge,  yungerAge, parentHouse, myParentHouse, myParentHousePrice</p>
<p>​        帕斯卡命名法（大驼峰命名法）：所有单词都首字母大写。</p>
<p>​            ChildAge,  YungerAge, ParentHouse, MyParentHouse, MyParentHousePrice</p>
<h2 id="变量的4种基本操作"><a href="#变量的4种基本操作" class="headerlink" title="变量的4种基本操作"></a>变量的4种基本操作</h2><p><strong>赋值——常见操作</strong></p>
<p>​        将一个数据（值）放入一个变量中。</p>
<p>​        $name = “张三丰”;</p>
<p>​        几乎所有变量要想后续正常使用，第一件事就是“赋值”。</p>
<p>​        变量初始赋值后，可以后续再去重新赋值——这就是修改了变量的值，比如：</p>
<p>​        $name = “张三不疯”;</p>
<p>​        变量赋值的本质是：将变量名，跟一个数据“建立关联（联系）”，图示如下：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527083717.png" alt="" loading="lazy"></p>
<p><strong>取值——常见操作</strong></p>
<p>​        取值，就是，从变量这个容器中拿到其中存储的数据（值）；</p>
<p>​        取值无处不在：凡是使用到变量，并在该位置上，需要一个“数据”的时候，就会发生取值操作</p>
<p><strong>判断变量isset()</strong></p>
<p>​        就是判断一个“变量名”是否里面存储了数据！</p>
<p>​        判断的结果是：true（真，表示有），或者false（假，表示没有）。</p>
<p>​        ==使用这个语法来判断：isset( $变量名 );==</p>
<p>​        还有一个特殊的赋值，赋值后，变量中也没有数据，如下：</p>
<p>​        ==$v5 = null;       //null是一个特殊的“数据”（值），该数据的含义是：没有数据。==</p>
<p>​        ==即此时判断 isset($v5)的结果是“false”。==</p>
<p><strong>删除/销毁变量unset()</strong></p>
<p>​        当一个变量中存储了数据，我们也可以去销毁（删除）它，语法如下：</p>
<p>​            ==unset( $变量名 ）==。</p>
<p>​            ==删除变量的本质是：断开变量名跟其关联过的那个数据之间的“联系”==，图示如下：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527085016.png" alt="" loading="lazy"></p>
<p>​        此时，该变量就不再指向某个数据了，其isset()判断的结果为false。</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527085142.png" alt="" loading="lazy"></p>
<h2 id="变量传值（难点）"><a href="#变量传值（难点）" class="headerlink" title="==变量传值（难点）=="></a>==变量传值（难点）==</h2><p><strong>含义：</strong></p>
<p>​        是指，将一个变量的值“传递”给另一个变量的方式问题。</p>
<p>​        形式上，就是一个变量在等号左边，一个变量在等号右边，就表示将右边变量的值传给左边的变量。</p>
<p>​        ==有且只有两种传数据的方式：值传递，和引用传递。==</p>
<p><strong>值传递：</strong></p>
<p>​        就是将右边变量的“数据值”本身，复制一份，然后赋值给左边变量。</p>
<p>​        形式如下：</p>
<p>​            $变量1 = $变量2；</p>
<p>​        举例：</p>
<p>​            $v1 = 1;</p>
<p>​            $v2 = $v1;</p>
<p>​        可见：</p>
<p>​            ==值传递之后，两个变量互不影响，相互独立，没有关系了==！</p>
<p>​        其原理如下所示：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527090938.png" alt="" loading="lazy"></p>
<p>​        可见，此时两个变量在赋值之后，就相互独立，各自有自己的存放空间。改变一个，另一个不受影响。</p>
<p>​        代码演示：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091011.png" alt="" loading="lazy"></p>
<p><strong>==引用传递：==</strong></p>
<p>​        是将右边变量对数据的引用关系，传给左边的变量。</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527090938.png" alt="" loading="lazy"></p>
<p>​        代码演示：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091011.png" alt="" loading="lazy"></p>
<h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="==预定义变量=="></a>==预定义变量==</h2><p>​        在PHP语言内部，有一些（也就10来个）变量，是现成的，直接可以使用，这就是所谓预定义变量。</p>
<p>我们要做的是事情就是：理解该变量是什么意思，以及怎么用</p>
<h3 id="GET变量"><a href="#GET变量" class="headerlink" title="$_GET变量"></a>$_GET变量</h3><p>​        代表浏览器表单通过“get”方式提交的所有数据（集），可以称为“get数据”。</p>
<p>​        也可以理解为：</p>
<p>​            $_GET变量里面会“自动存储”（保存/装载）提交到某个文件中的GET数据。</p>
<p>​            而GET数据，是在一个页面以“get”方式请求的时候提交的数据。</p>
<p>​        代码演示：</p>
<p>​        制作一个表单，有两个输入框，可以输出数字，并提交。</p>
<p>​        到另一个页面（文件）中，计算这两个数字的和！</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091422.png" alt="" loading="lazy"></p>
<h3 id="POST"><a href="#POST" class="headerlink" title="$_POST"></a>$_POST</h3><p>​        代表浏览器表单通过“post”方式提交的所有数据（集），可以称为“POST数据”。</p>
<p>​        也可以理解为：</p>
<p>​            $_POST变量里面会“自动存储”（保存/装载）提交到某个文件中的POST数据。</p>
<p>​            而POST数据，是在一个表单中以“post”方式提交的数据。</p>
<p>​    </p>
<p>​        代码演示：</p>
<p>​            有个表单，两个输入框，可以填写数字，有一个“提交按钮”，点击提交，可以计算他们的和并输出。</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091526.png" alt="" loading="lazy"></p>
<p>​        扩展（提交给自己！）：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091559.png" alt="" loading="lazy"></p>
<h3 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$_REQUEST"></a>$_REQUEST</h3><p>​        代表浏览器通过“get”方式 或 “post”方式提交的数据的合集。</p>
<p>​        即：它既能接收到get过来的数据，也能接收到post过来的数据！</p>
<p>​        通常，一个表单，只提交一种形式的数据，要么get数据，要么post数据！</p>
<p>​        代码演示：</p>
<p>​        但，有一个情况，提交post数据的同时，也可以提交get数据：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091644.png" alt="" loading="lazy"></p>
<h3 id="SERVER变量"><a href="#SERVER变量" class="headerlink" title="$_SERVER变量"></a>$_SERVER变量</h3><p>​        它代表任何一次请求中，==客户端或服务器端的一些“基本信息”或系统信息==，包括很多（10多项）。</p>
<p>我们无非就是要知道，哪些信息是可以供我们使用的！</p>
<p>​        常用的有：</p>
<p>​            PHP_SELF：         表示当前请求的网页地址（不含域名部分）</p>
<p>​            SERVER_NAME：    表示当前请求的服务器名</p>
<p>​            SERVER_ADDR：    表示当前请求的服务器IP地址</p>
<p>​            DOCUMENT_ROOT： 表示当前请求的网站物理路径（apache设置站点时那个）</p>
<p>​            REMOTE_ADDR：  表示当前请求的客户端的IP地址</p>
<p>​            SCRIPT_NAME：     表示当前网页地址\</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091845.png" alt="" loading="lazy"></p>
<h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><p><strong>含义：</strong></p>
<p>​        变量名本身又是一个“变量”的变量。</p>
<p>示例：</p>
<p>​        $v1 = 10;</p>
<p>​        echo $v1;   //输出10</p>
<p>​        $str = “v1”;   //这是一个变量，名为str，值为“v1”（字符串）</p>
<p>​        echo $$str;  //输出10。这里，“$$str”就是所谓的“可变变量”</p>
<p>​                        //相当于 echo $v1;   结果就是10</p>
<p>代码演示：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527092047.png" alt="" loading="lazy"></p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p><strong>常量的含义</strong></p>
<p>​        常量，就是一个用于存储“不会（也不允许）变化的数据”的标识符。</p>
<p>​        比如圆周率，在一定的应用场景中，就是是一个固定的值（人为规定为某个值）。</p>
<h2 id="常量的两种定义形式"><a href="#常量的两种定义形式" class="headerlink" title="常量的两种定义形式"></a>常量的两种定义形式</h2><p><strong>define()函数形式</strong></p>
<p>​        define(‘常量名’, 对应的常量值);</p>
<p>​        ==常量名推荐使用“全大写”。==</p>
<p><strong>const关键字定义：</strong></p>
<p>​        const 常量名 = 对应的常量值;</p>
<h2 id="常量的两种取值形式"><a href="#常量的两种取值形式" class="headerlink" title="常量的两种取值形式"></a>常量的两种取值形式</h2><p><strong>直接使用：</strong></p>
<p>​        echo 常量名；      //注意：使用常量，前面不带”$”符号，也不能有引号</p>
<p><strong>使用constant()函数以取值：</strong></p>
<p>​        echo constant(‘常量名’);      //注意，此时常量名要用引号引起来。</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527094710.png" alt="" loading="lazy"></p>
<h2 id="变量与常量的区别："><a href="#变量与常量的区别：" class="headerlink" title="变量与常量的区别："></a>变量与常量的区别：</h2><p>​        1. 变量的数据可以变化（重新赋值），常量不可以。</p>
<p>​        2. ==变量可以存储各种数据类型，而常量只能存储简单数据类型。==</p>
<p>​        3. 给变量赋值可以是“计算”结果，但给常量赋值，只能是“直接写出的值”（字面值）</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527094840.png" alt="" loading="lazy"></p>
<h2 id="判断一个常量是否存在：defined"><a href="#判断一个常量是否存在：defined" class="headerlink" title="判断一个常量是否存在：defined();"></a>判断一个常量是否存在：defined();</h2><p>​        判断的结果返回：true（表示存在）或false（表示不存在）</p>
<p>形式：</p>
<p>​        if（ defined (‘常量名’) ) {     //如果该常量名存在，则….</p>
<p>​                //….做什么事情。。。。</p>
<p>​            }</p>
<p>演示：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527094955.png" alt="" loading="lazy"></p>
<h2 id="预定义常量"><a href="#预定义常量" class="headerlink" title="预定义常量"></a>预定义常量</h2><p>​        预定义常量就是PHP语言内部预先定义好的常量，我们可以直接使用。</p>
<p>​        比如：PHP_VERSION, PHP_OS, PHP_INT_MAX, M_PI等。</p>
<p>​        PHP_VERSION： 表示当前php的版本信息</p>
<p>​        PHP_OS：       表示当前php运行所在的系统信息</p>
<p>​        PHP_INT_MAX： 表示当前版本的php中的最大的整数值</p>
<p>​        M_PI：         表示圆周率π（一个有10多位小数的数）</p>
<p>查手册，预定义常量如下：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527095138.png" alt="" loading="lazy"></p>
<h2 id="几个魔术常量"><a href="#几个魔术常量" class="headerlink" title="几个魔术常量"></a>几个魔术常量</h2><p><strong>含义：</strong></p>
<p>​        魔术常量也是常量，只是在形式上为常量，而其值其实是“变化”的。</p>
<p>他们也是系统中预先定义好的，也就几个，下面是最常用的 3个：</p>
<p><strong>_<em>DIR_</em></strong>         ：代表当前php网页文件所在的目录</p>
<p>*<em>_<em>FILE_</em> *</em>      ：代表当前php网页文件本身的路径</p>
<p><strong>_<em>LINE_</em></strong>,     ：代表当前这个常量所在的行号</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527095443.png" alt="" loading="lazy"></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数据类型分类与概述"><a href="#数据类型分类与概述" class="headerlink" title="数据类型分类与概述"></a>数据类型分类与概述</h2><p><strong>==标量类型==</strong></p>
<p>​        标量类型也可以理解为“基本类型”，“简单类型”。</p>
<p>​        标量类型包括如下4种：</p>
<p>​        字符串类型：String</p>
<p>​                就是一串字符串，当做一个整体，表示一个连续有确定顺序的字符串。</p>
<p>​                通常需要使用单引号或双引号来引起来，比如：</p>
<p>​                $name = “张三”;</p>
<p>​        整数类型：Int， Integer</p>
<p>​        浮点数： Float， Double</p>
<p>​        就是数学上的小数。</p>
<p>​        布尔类型： Bool， Boolean</p>
<p>​                这种数据类型只有两个数据：true， false</p>
<p>​                $is_graduate = true;</p>
<p>​                $hasMoney = false;</p>
<p><strong>复合类型</strong></p>
<p>​        就是“数组”（Array）和“对象”（Object）两种。</p>
<p><strong>特殊类型</strong></p>
<p>​        空类型： 有且只有一个数据可以使用，那就是null</p>
<h2 id="整型integer，int"><a href="#整型integer，int" class="headerlink" title="整型integer，int"></a>整型integer，int</h2><p>可以有4种直接书写的形式：</p>
<p>​        10进制形式：</p>
<p>​                $n1 = 123;</p>
<p>​        8进制形式：</p>
<p>​                $n1 = 0123;      ==//以0开头==</p>
<p>​        16进制形式：</p>
<p>​                $n1 = 0x12A34;  ==//以0x开头，还可以有A，B，C，D，E，F这个6个“16进制数字”==     </p>
<p>​        2进制形式：</p>
<p>​                $n1 = 0b1011011010;   ==//以0b开头==</p>
<p>下表为进制对比：        </p>
<table>
<thead>
<tr>
<th>10  进制</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
</tr>
</thead>
<tbody><tr>
<td>8  进制</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>20</td>
</tr>
<tr>
<td>16  进制</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>10</td>
</tr>
<tr>
<td>2进制</td>
<td>0</td>
<td>1</td>
<td>10</td>
<td>11</td>
<td>100</td>
<td>101</td>
<td>110</td>
<td>111</td>
<td>1000</td>
<td>1001</td>
<td>1010</td>
<td>1011</td>
<td>1100</td>
<td>1101</td>
<td>1110</td>
<td>1111</td>
<td>10000</td>
</tr>
</tbody></table>
<p><strong>进制的相互转换</strong></p>
<p>直接通过系统函数来进行，能完成：</p>
<p>10进制转为2, 8, 16进制：</p>
<p>​        decbin()：将10进制转为2进制</p>
<p>​        decoct()：将10进制转为8进制</p>
<p>​        dechex()：将10进制转为16进制</p>
<p>或：</p>
<p>2, 8, 16进制转为10进制：</p>
<p>​        bindec()：将2进制数字字符串转为10进制</p>
<p>​        octdec()：将8进制数字字符串转为10进制</p>
<p>​        hexdec()：将16进制数字字符串转为10进制</p>
<h2 id="浮点型float"><a href="#浮点型float" class="headerlink" title="浮点型float"></a>浮点型float</h2><p>浮点数就是相当于数学上的“小数”</p>
<p>两种书写形式：</p>
<p>​        直接小数点形式：</p>
<p>​                $f1 = 0.1;     //或者1.23;  123.0;</p>
<p>​        科学计数法</p>
<p>​                $f2 = 1.23e3;    ==//表示1.23 乘以10的3次方==</p>
<p>​                $f3 = 123e2;      ==//这个也是浮点数，虽然其结果值是一个“整数”（12300==</p>
<p>==<strong>特别注意：浮点数不要做相等比较（==）</strong>：因为浮点数进行相等比较，是“不可靠”的:==</p>
<p>​        $v1 = 0.1 + 0.2;</p>
<p>​        $v2 = 0.3;</p>
<p>​        问：$v1和$v2相等吗？</p>
<h2 id="布尔型Boolean"><a href="#布尔型Boolean" class="headerlink" title="布尔型Boolean"></a>布尔型Boolean</h2><p>只有两个数据值： true， false（不区分大小写）</p>
<p>在需要当做“布尔值”进行判断或比较的时候，以下数据会被当作布尔值的 false：</p>
<p>​        ==false, 0, 0.0, “”,  null, ‘0’, 空数组==</p>
<p>其余都被当做布尔值的 true。</p>
<p>常见应用代码类似这样：</p>
<p>​        $v1 = 某某值; </p>
<p>​        if( $v1 ) { //此时，如果$v1为上述值之一，就会当做false，不执行其中的代码。</p>
<p>​        。。。代码。。。</p>
<p>​        }</p>
<p>​        //而对于其他值，就会当做true，因此就会执行其中的代码。</p>
<h2 id="字符串型String"><a href="#字符串型String" class="headerlink" title="字符串型String"></a>字符串型String</h2><p>可以使用单引号或双引号来表示（引起来）。</p>
<p>表示一串“连续的字符”，最短的字符串是“空字符串”，比如： $str1 = “”。</p>
<p>​        ==注意：这个不是空字符串： “  ”， 因为其中包括了1个空格字符。==</p>
<p>$name = “张三”;</p>
<p>$edu = ‘北京大学’;</p>
<p>$title = “关于微信应用的几个改进建议”；    //文章标题</p>
<p>$v1 = ‘’;     //这也是字符串（空字符串）</p>
<p>$v2 = ‘123’;      //这还是字符串</p>
<p>$v3 = “false”;     //这仍然是字符串</p>
<p>特别注意：</p>
<p>​        ==双引号字符串中，如果出现“$”符号，则该符号后的连续字符（单词）会被识别为一个变量名。==</p>
<p>​        ==如果识别成功（即确实存在该变量），则会将该变量转换为实际内容。==</p>
<p>​        ==如果识别失败（即实际没有该变量），则会报错。==</p>
<h2 id="数组类型Array"><a href="#数组类型Array" class="headerlink" title="数组类型Array"></a>数组类型Array</h2><p>​    </p>
<p>数组，就是将多个“数据”放在一起，排成一个序列，这个序列作为一个整体（里面包括了多个数据），就称为“数组”。比如：</p>
<p>​        $arr1 = array(‘张三丰’, 18, “男” );</p>
<p>​        或另一种形式：</p>
<p>​        $arr2 = array(‘name’ =&gt; ‘张三丰’, ‘age’=&gt;18, ‘gender’ =&gt; “男” );</p>
<p>数组的赋值：</p>
<p>​        $数组变量[下标] = 一个值；</p>
<p>数组的取值：</p>
<p>​        行为为：$数组变量[下标]</p>
<p>​        比如： echo $arr1[0];     print_r( $arr2[‘name’] )；</p>
<p>其内部结构，可以这样去理解：</p>
<p>$info内部结构：</p>
<table>
<thead>
<tr>
<th>键名/下标/索引</th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody><tr>
<td>值</td>
<td>‘张三丰’</td>
<td>18</td>
<td>‘男’</td>
</tr>
</tbody></table>
<p>这种下标，通常称为“数字下标”。</p>
<p>$info2内部结构：</p>
<table>
<thead>
<tr>
<th>键名/下标/索引</th>
<th>‘name’</th>
<th>‘age’</th>
<th>‘gender’</th>
</tr>
</thead>
<tbody><tr>
<td>值</td>
<td>‘张三丰’</td>
<td>18</td>
<td>‘男’</td>
</tr>
</tbody></table>
<p>这种下标，通常被称为“字符串下标”。</p>
<h2 id="空类型NULL"><a href="#空类型NULL" class="headerlink" title="空类型NULL"></a>空类型NULL</h2><p>只有一个值： null（不区分大小写）。</p>
<p>$v1 = null;   //此时，具有变量$v1,但其中的数据是“空的”（没有数据）</p>
<p>==空值变量，isset()判断的结果是false（即不存在）。==</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>==gettype()==： 获取一个变量的类型，结果为一个变量类型的名称（字符串）</p>
<p>​        $v1 = 10;</p>
<p>​        $r1 = gettype( $v1 );   //结果为：“integer”</p>
<p>​        $v2 = ‘abc’;</p>
<p>​        $r2 = gettype( $v2 );   //结果为：“string”</p>
<p>==settype()==： 设置一个变量的类型</p>
<p>​        $v1 = 10;     //此时，$v1中数据是整数类型</p>
<p>​        settype( $v1, ‘string’); //此时，$v1是字符串类型，即其中的数据变成了：“10”</p>
<p>var_dump()： 输出变量的“完整信息”，包括变量类型，长度（如果需要），内容</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527145758.png" alt="" loading="lazy"></p>
<p>==判断是否为某种类型（类型系列函数）==： </p>
<p>​        is_int() / is_integer()：判断是否为整数类型</p>
<p>​        is_float()：判断是否为浮点类型</p>
<p>​        is_bool()：判断是否为布尔类型</p>
<p>​        is_string()：。。。</p>
<p>​        is_array()：。。。</p>
<p>​        is_numeric()：判断是否为“数字”类型（含整数，小数，以及“纯数字字符串”）</p>
<p>​        is_object()：</p>
<p>两个特殊判断：</p>
<p>​        ==isset()： 判断一个变量中是否有数据，如果有返回true，如果没有(即此时就是null)返回false==</p>
<p>​        ==empty()：判断是否为“空的”。如果确实是“空的”，返回true，否则返回false。==</p>
<p>​                “空的”的意思，比较接近日常生活中的“没有”。</p>
<p>​                而空（null）是一个计算机中的特殊概念，表示“完全不存在”，可以理解为“真空”。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>自动转换</strong></p>
<p>我们无需做任何处理，而是，==程序会根据运算时运算符所需要的数据类型进行转换。==</p>
<p>如果参与运算的数据不是需要的类型，则会自动转换为需要的数据类型。</p>
<p>$v1 = 1 + “3”; //结果是4；</p>
<p>$v2 = 1 . “3”;  //“.”是字符串连接符，这里，1会被转换为字符串，结果是：“13”</p>
<p>典型自动转换：</p>
<p>​        转换为数字：</p>
<p>​            1+”2”           //</p>
<p>​            “1” + “2”         //</p>
<p>​            1 + ”2abc”       //</p>
<p>​            1 + ”2abc34”      //</p>
<p>​            1 + “abc”         //</p>
<p>​            1 + “abc2”       //</p>
<p>​            1.2 + “2”         //</p>
<p>​            1.2 + “2.2abc”     //</p>
<p>​            1.2 + “abc2.2”     //</p>
<p>​            “1.2abc” + 2      //</p>
<p>​            “1.2abc” + “2abc”  //</p>
<p>​        转换为整数：</p>
<p>​            10.8 % 3.6</p>
<p>​            “10.8” % “3.6”</p>
<p>​            “10.8” % “3.6abc”</p>
<p>​            “10.8ab” % “3.6cd”</p>
<p><strong>强制转换:</strong></p>
<p>人为使用强转换语法进行转换，比如：\</p>
<p>​        $v1 = (int) “1”;   //结果，$v1是整数类型的1</p>
<p>​        $v2 = (float) “1.23”;  //结果，$v2是浮点类型的1.23</p>
<p>​        $v3 = (string) $v1; //结果，$v3是字符串“1”</p>
<h1 id="运算符详解"><a href="#运算符详解" class="headerlink" title="运算符详解"></a>运算符详解</h1><p><strong>含义；</strong></p>
<p>​        就是对数据进行某种所需要的运算的语法符号，比如加减乘除，或比较大小，或判断真假。</p>
<p><strong>按参与运算的数据的个数来分类</strong></p>
<p>单目运算符：</p>
<p>​        只需要一个数据——但必须是变量。</p>
<p>双目运算符：</p>
<p>​        需要两个数据——可以是变量，也可以直接的数据本身。</p>
<p>三元运算符：</p>
<p>​        需要3个数据才能运算，也称为三目运算符。</p>
<p>​        只有一个三元运算符。</p>
<p><strong>按功能分类</strong></p>
<p>​        赋值运算符：</p>
<p>​        = </p>
<p>​        算术运算符：</p>
<p>​        + - * / %</p>
<p>​        连接运算符：</p>
<p>​        .</p>
<p>​        自赋值运算符：</p>
<p>​        +=  -=  *=  /=  %=  .=</p>
<p>​        自操作运算符：</p>
<p>​            ++  –</p>
<p>​        比较运算符：</p>
<p>​            &gt;  &gt;=  &lt;  &lt;= == !=  ===  !==</p>
<p>​        逻辑运算符：</p>
<p>​            &amp;&amp;(与）  ||（或）  ！（非）</p>
<p>​        条件运算符：</p>
<p>​            数据1 ? 数据2  : 数据3</p>
<p>​        位运算符：</p>
<p>​            &amp;  |  ~ </p>
<p>​        其他：</p>
<p>​            @，是错误抑制符</p>
<p>​            ( )，括号，用于提升运算优先级，括号中的先运算。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>只要理解一个核心的观念：</p>
<p>​        ==就是将等号（=）右边的数据（可能是运算结果数据）赋值给左边的变量。==</p>
<p>​        看看一下写法：</p>
<p>​        $v1 = 1;</p>
<p>​        $v2 = 2;</p>
<p>​        $v3 = $v1 + $v2;</p>
<p>​        $v1 + $v2 = $v3;  //可以吗？不可以！</p>
<p>​        if( $v1 + $v2 = $v3 ){….} //可以吗？？？还是不可以！</p>
<p>​        ==一定记住，一个等号的左边，只能是一个“变量名”！==</p>
<p>​        ==所以，这个写法是错误的：  $v1+2 = $v2 + 3==</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>针对数字进行的算术计算，包括：+ - * / %</p>
<p>%：对整数数字进行“==取余操作==”——如果不是整数，会先自动转换为整数之后再进行取余。</p>
<p>​                                                             转换为整数的做法是：直接去掉小数部分</p>
<p>比如：</p>
<p>​        $v1 = 10 % 3;  //结果为1</p>
<p>​        $v2 = 10.8 % 3.6  //结果为1</p>
<h2 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符( . )"></a>连接运算符( . )</h2><p>就是字符串的连接，能够将前后字符连接起来。</p>
<p>如果不是字符串，会自动转换为字符串。</p>
<p>$v1 = “ab” . “cd”;</p>
<p>$v2 = $v1 . “ef”;</p>
<p>$v3 = “ab” . 12;       //“ab12”</p>
<p>$v4 = 12 . 34;      //”1234”</p>
<p>$v5 = “12” . true;   //“121”，true转为字符串，为“1”；</p>
<p>$v6 = “12” . false;  //“12”，false转为字符串，为“”（即空字符串）；</p>
<h2 id="自赋值运算符"><a href="#自赋值运算符" class="headerlink" title="自赋值运算符"></a>自赋值运算符</h2><p>针对数字的，包括： +=  -=  *=  /=  %= </p>
<p>针对字符串的，只有一个：.=</p>
<p>形式：</p>
<p>​        ==$变量 += 数据；==</p>
<p>​        相当于这个赋值语句： ==$变量 = $变量 + 数据；==</p>
<p>​        此时，其实是相当于该变量的值，跟给定的数据进行运算后的结果数据，再放回到该变量中（覆盖了之前的数据）。</p>
<h2 id="自操作-自加自减）运算符"><a href="#自操作-自加自减）运算符" class="headerlink" title="自操作(自加自减）运算符"></a>自操作(自加自减）运算符</h2><p>针对整数，只有2个：++  –  </p>
<p>属于单目运算符，即只要一个变量就可以进行运算。</p>
<p>形式：</p>
<p>​        $变量++；   //对该变量中数据+1</p>
<p>​        $变量–；   //对该变量中数据-1</p>
<p>​        ++$变量；   //对该变量中数据+1</p>
<p>​        –$变量；   //对该变量中数据-1</p>
<p>++讨论：</p>
<p>​        表示对该变量进行“自加1”操作。即该变量中的数据加1。</p>
<p>​        前自加：</p>
<p>​        后自加：</p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>含义：</p>
<p>​        是针对数字的大小进行比较的运算。</p>
<p>​        如果不是数字，会自动转换为数字。</p>
<p>​        包括：  &gt;  &gt;=  &lt;  &lt;=  == !=  ===  !==</p>
<p>​        所有比较运算符，运算的结果只有两个可能（之一）： true 或 false</p>
<p>​        比如：</p>
<p>​        if( 1 == 2);       //结果是false</p>
<p>等于（==）和全等于（===）的区别：</p>
<p>通常，等于（==）也会用“模糊相等”或“松散比较”的说法。</p>
<p>两个数据“基本相等”（类型可能会发生自动转换），就算是相等。</p>
<p>全等于（===）就是完全相等：</p>
<p>只有两个数据的数据类型一样，并且其值也一样的时候，才是全等。</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>针对“布尔值”进行的运算，只有3个： </p>
<p>​        与：    &amp;&amp;  </p>
<p>​        或：    ||  </p>
<p>​        非：    ！</p>
<p>如果不是布尔值，会自动转换为布尔值去进行运算。</p>
<p>因为布尔值只有2个，不管怎么排列组合，最终只有以下10种情况的计算，几乎就是公式化。</p>
<p><strong>逻辑与（&amp;&amp;）：</strong></p>
<p>含义：</p>
<p>​        表示两个条件（数据）的真假结果是否同时为真的共同作用结果。</p>
<p>​        运算结果：只有两个条件都为真的时候，结果才是真（true）。</p>
<p>只有如下4种情况：</p>
<p>​        true &amp;&amp; true      结果为 true</p>
<p>​        true &amp;&amp; false     结果为 false</p>
<p>​        false &amp;&amp; true      结果为 false</p>
<p>​        false &amp;&amp;false     结果为 false</p>
<p><strong>逻辑或（||）：</strong></p>
<p>含义：</p>
<p>​        表示两个条件（数据）的真假结果的是否存在“真”的情况的共同作用结果。</p>
<p>运算规则：</p>
<p>​        只要有任意一个条件为真（true），结果就是真。</p>
<p>只有如下4种情况：</p>
<p>​        true || true    结果为 true</p>
<p>​        true || false   结果为true</p>
<p>​        false || true   结果为 true</p>
<p>​        false ||false   结果为 false</p>
<p><strong>逻辑非（！）：</strong></p>
<p>就是对一个布尔值进行“取反”操作，规则为：</p>
<p>​        !true   结果为false</p>
<p>​        !false   结果为true</p>
<p>逻辑非（！）在if中的常见应用情形：</p>
<p>​        if( !isset( $v1 ) ){….}   //如果$v1为空（null）</p>
<p>​        if( !empty( $v1 ) ){…}     //如果$v1不为空（empty）</p>
<p>​        对应的两个相反的情形是：</p>
<p>​        if( isset( $v1 ) ){….}     //如果$v1存在</p>
<p>​        if( empty( $v1 ) ){…}     //如果$v1为空（empty）</p>
<p>区分两个“空”：</p>
<p>​        null：   “真空”，什么都没有，是明确定义的“没有数据”的一种写法（含义）</p>
<p>​        empty：“现实意义上的没有”，就是无，就是0,等等，常见的，认为是empty的数据有：</p>
<p>​                        ==“”（空字符串）, 0, 0.0, “0”, false, null, 空数组，==</p>
<p><strong>逻辑运算的短路规则：</strong></p>
<p>短路：</p>
<p>​        就是对于“逻辑与” 或 “逻辑或”这两种运算符，他们可能会只进行左侧的逻辑判断之后，立即就中断后续（右侧）的判断，而得出整个逻辑运算符的运算结果！</p>
<p>​        if ( 左侧判断 &amp;&amp; 右侧判断 )</p>
<p>​        if ( 左侧判断 || 右侧判断 )</p>
<p>举例：</p>
<p>​        判断一个整数（比如13）是否能被3整除并且能被5整除！</p>
<p><strong>结论：</strong></p>
<p>我们应该将我们可能发生短路运算的逻辑判断的前后判断语句，做如下调整：</p>
<p>​        相对简单的运算放前面（左侧），相对复杂的运算放后面（右侧）。</p>
<p>对于逻辑或的短路运算，道理一样。</p>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>​        </p>
<p>只有一个条件运算符，形式为：</p>
<p>​        表达式1 ？ 表达式2 ：表达式3</p>
<p><strong>含义：</strong></p>
<p>​        如果表达式1为true（或自动转换后为true），则运算的结果值为表达式2，否则为表达式3。</p>
<p><strong>举例：</strong></p>
<p>​        $score = 77;  //分数</p>
<p>​        $v1 = $score &gt;= 60 ? “及格” ： “不及格”；</p>
<p>其本质是：</p>
<p>​        $score = 77;  //分数</p>
<p>​        if ( $score &gt;= 60 ){</p>
<p>​            $v1 = “及格”；</p>
<p>​        }</p>
<p>​        else{</p>
<p>​            $v1 = “不及格”；</p>
<p>​        }</p>
<h2 id="位运算符（了解）"><a href="#位运算符（了解）" class="headerlink" title="位运算符（了解）"></a>位运算符（了解）</h2><p>​        针对整数进行的二进制级别的运算。</p>
<p>​        基本位运算符包括：按位与（ &amp; ）， 按位或（ | ）， 按位非（ ~ ）， 按位异或（^）</p>
<p><strong>位运算基本运算规则：</strong></p>
<p>位运算符有如下基本运算规则：</p>
<p>​    （只针对二进制的0和1这两个数据的基本位运算规则）：</p>
<p>按位与（&amp;）运算规则：</p>
<p>​        0 &amp; 1 结果为：0</p>
<p>​        0 &amp; 0 结果为：0</p>
<p>​        1 &amp; 0 结果为：0</p>
<p>​        1 &amp; 1 结果为：1</p>
<p>​        ==结论：只有两个都是1，按位与运算结果才是1==</p>
<p>按位或（|）运算规则：</p>
<p>​        0 | 1 结果为：1</p>
<p>​        0 | 0 结果为：0</p>
<p>​        1 | 0 结果为：1</p>
<p>​        1 | 1 结果为：1</p>
<p>​        ==结论：只有两个都是0，按位或运算结果才是0==</p>
<p>按位非（~）：</p>
<p>​        ~1结果为0</p>
<p>​        ~0结果为1</p>
<p>按位异或（^）：</p>
<p>​        0 ^ 1 结果为：1</p>
<p>​        0 ^ 0 结果为：0</p>
<p>​        1 ^ 0 结果为：1</p>
<p>​        1 ^ 1 结果为：0</p>
<p>​        ==规则是：相同为0，不同为1==</p>
<h2 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="==错误抑制符@=="></a>==错误抑制符@==</h2><p>含义：</p>
<p>​        在一个表达式出现错误的时候，可以将错误“隐藏”（掩盖）起来（不输出）！</p>
<p>通常，该符号，用于在实际运行环境中的一些条件非我们（程序员）所能控制的情形。</p>
<p>如果出现该情形并报错，则我们可以抑制该错误的显示（只是该错误不显示，不是没有错误了）。</p>
<p>典型应用场景：</p>
<p>​        if( @mysqli_connect(‘localhost’, ‘root’, ‘123’ ) ){</p>
<p>​        …….</p>
<p>​        }</p>
<h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>运算符优先级不得不说的规则：</p>
<ol>
<li><p>时刻意识到，运算符有优先级问题！</p>
</li>
<li><p>小括号可以改变运算的顺序（即括号最优先）</p>
</li>
<li><p>先乘除（以及取余）后加减；</p>
</li>
<li><p>大致有如此优先级规则：算术运算 &gt; 比较运算 &gt; 逻辑运算</p>
</li>
<li><p>赋值运算符通常都是最后（优先级最低）</p>
</li>
</ol>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="流程控制概述"><a href="#流程控制概述" class="headerlink" title="流程控制概述"></a>流程控制概述</h2><p>顺序结构：</p>
<p>​        程序运行的自然状态，就是从前往后（从上到下）运行程序。</p>
<p>分支结构：</p>
<p>​        程序运行过程中，根据判断条件的不同结果(true或false)，执行不同的分支（其他分支不再执行）。</p>
<p>循环结构：</p>
<p>​        程序运行过程中，根据判断条件的不同结果(true或false)，决定是再次执行还是不再执行。</p>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><strong>单分支</strong></p>
<p>​        形式：</p>
<p>​            if ( 条件判断 ）{</p>
<p>​                    //如果条件满足，就执行这里</p>
<p>​            }</p>
<p><strong>双分支</strong></p>
<p>​        形式：</p>
<p>​            if ( 条件判断 ）{</p>
<p>​                    //如果条件满足，就执行这里</p>
<p>​            }</p>
<p>​            else{</p>
<p>​                    //如果条件不满足，就执行这里</p>
<p>​                }</p>
<p><strong>多分枝</strong></p>
<p>​        形式：</p>
<p>​                if ( 条件判断1 ）{</p>
<p>​                        //分支1；</p>
<p>​                    }</p>
<p>​                elseif( 条件判断2 ）{</p>
<p>​                    //分支2；</p>
<p>​                    }</p>
<p>​                    elseif( 条件判断3 ）{</p>
<p>​                        //分支3；</p>
<p>​                    }</p>
<p>​                            。。。。。。。前面的elseif分支，可以若干个（0个以上）</p>
<p>​                    else{</p>
<p>​                //最后的else分支，可以没有！</p>
<p>​                        }</p>
<h2 id="分支结构之switch分支语句（重点）"><a href="#分支结构之switch分支语句（重点）" class="headerlink" title="分支结构之switch分支语句（重点）"></a>分支结构之switch分支语句（重点）</h2><p><strong>语法：</strong></p>
<p>​        switch（ 一个变量数据或表达式结果$v1 ）{</p>
<p>​                case 值1：         //如果$v1 等于 这个“值1”，就执行本分支</p>
<p>​                        分支语句1；</p>
<p>​                        break；          //表示跳出该分支，也就是跳出switch语句。</p>
<p>​                case 值2：         //如果$v1 等于 这个“值2”，就执行本分支</p>
<p>​                        分支语句2；</p>
<p>​                        break；</p>
<p>​                    。。。。。。     //可以更多的分支</p>
<p>​                default：</p>
<p>​                        默认分支；      //前面都不满足的时候，就执行这里</p>
<p>​                }</p>
<p><strong>说明：</strong></p>
<p>​        1. 上述“值1，值2，。。。”可以是各种标量类型，也可以是表达式——因为最终它也是一个值。</p>
<p>​        2. 用于进行测试的数据变量$v1跟后续的各个值，只能进行“相等比较”（==）。</p>
<p>​        3. 从上述第2条角度来说，其实际上不如if灵活。</p>
<p><strong>注意：</strong></p>
<p>​        当某个分支满足条件并执行该分支后，如果该分支中没有break语句，此时，程序的流程会“直接进入”后一个分支继续执行，直到碰到break才会结束switch。</p>
<h2 id="循环结构之while循环语句"><a href="#循环结构之while循环语句" class="headerlink" title="循环结构之while循环语句"></a>循环结构之while循环语句</h2><p>while循环语法：</p>
<p>​        while（条件判断）{</p>
<p>​            。。。。循环体语句；</p>
<p>​        }</p>
<p>说明：</p>
<p>​        循环一开始就进行条件判断：</p>
<p>​                如果成立：则执行循环体，而后会自动回到循环开始位置继续进行条件判断，如此反复；</p>
<p>​                如果不成立：则退出循环，执行后续语句。</p>
<h2 id="循环结构之do-while循环语句"><a href="#循环结构之do-while循环语句" class="headerlink" title="循环结构之do while循环语句"></a>循环结构之do while循环语句</h2><p><strong>do while循环语法：</strong></p>
<p>​        do {</p>
<p>​            。。。。循环体语句；</p>
<p>​            }while（条件判断）；</p>
<p><strong>说明：</strong></p>
<p>​        ==-先执行一次循环体，然后进行条件判断：==</p>
<p>​                如果成立：则继续回去执行循环体，而后再次进行条件判断，如此反复；</p>
<p>​                如果不成立：则退出循环，执行后续语句。</p>
<h2 id="循环结构之for循环语句（重点-难点"><a href="#循环结构之for循环语句（重点-难点" class="headerlink" title="==循环结构之for循环语句（重点/难点)=="></a>==循环结构之for循环语句（重点/难点)==</h2><p><strong>for循环语法：</strong></p>
<p>​        for（循环变量初始化1； 循环条件判断2； 循环变量的改变3）{</p>
<p>​                。。。。。。。。循环体语句块4；</p>
<p>​                //这里可以有多条语句</p>
<p>​                //是可以反复执行的部分</p>
<p>​            }</p>
<p><strong>说明：</strong></p>
<p>​        1. 执行流程如下图所示</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527154450.png" alt="" loading="lazy"></p>
<p>​        2. 此语句结构是将循环的3个要素都集中在一起写的形式，比较紧凑，容易控制，最常用。</p>
<p>​        3. 循环变量初始化语句1只执行一次，所以真正的正常循环，是在“2-&gt;4-&gt;3”之间进行</p>
<h2 id="多重循环及案例"><a href="#多重循环及案例" class="headerlink" title="多重循环及案例"></a>多重循环及案例</h2><p><strong>概念：</strong></p>
<p>​        多重循环就是循环里面由出现循环的代码。</p>
<p>​        其基本执行流程，其实仍然是循环的基本逻辑，只是循环的时候要注意：外层循环执行每一次，里层循环就会完整执行循环的“所有次”（一个完整循环的过程）。</p>
<h2 id="循环的中断"><a href="#循环的中断" class="headerlink" title="循环的中断"></a>循环的中断</h2><p>​        循环是按给定的条件，只要条件满足就会继续执行循环体的一种语法形式。</p>
<p>但，我们也可以在循环过程中（循环体内），人为将循环中断</p>
<p>有两种中断循环的方式：</p>
<p><strong>continue中断：</strong></p>
<p>​        含义：中断当前正在进行的循环体（即后续语句不再执行），继续下一次循环要执行的语句。</p>
<p>​        语法形式：</p>
<p>​                continue [$n]；      //表示是要中断第几层的循环，继续该层循环的下一次。</p>
<p>​                                                //其中$n可以省略，如果省略，表示1，就是中断当前层的循环。</p>
<p><strong>break中断：</strong></p>
<p>​            含义：停止（跳出）当前正在进行的循环（即完全终止循环），去执行该循环之后的语句。</p>
<p>​            语法形式：</p>
<p>​                    break [$n]；         //表示是要中断几层循环。</p>
<p>​                                                    //其中$n可以省略，如果省略，表示1，就是中断当前循环</p>
<p>​            他们都适用于3种循环。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的概念与作用"><a href="#函数的概念与作用" class="headerlink" title="函数的概念与作用"></a>函数的概念与作用</h2><p>函数不是数！</p>
<p>函数是一种代码形式（语法形式）。</p>
<p>函数是将“若干行代码”以一种语法形式包装成的一个整体。</p>
<p>该整体可以做到“需要的时候就去执行它”（就是执行其中的若干行代码）。</p>
<p>函数是解决在不同情形（不同代码位置）下需要执行相同代码的有效方式——即所谓<strong>代码重用</strong>。</p>
<p>函数通常用于“专业的事由专业的人来做”这种现实世界的常见现象。</p>
<p>​                比如油条摊：专门做油条，顾客随时需要，就随时可以买（付钱就可以）。</p>
<p>​                比如轮胎厂：专门生产不同型号轮胎，汽车制造厂随时需要就随时提供（付钱）。</p>
<p>​                比如豆浆机：专门制作豆浆，人们随时需要豆浆就随时可以启动豆浆机制作豆浆（提供豆子和水）。</p>
<h2 id="函数的定义与调用"><a href="#函数的定义与调用" class="headerlink" title="函数的定义与调用"></a>函数的定义与调用</h2><p><strong>定义语法形式：</strong></p>
<p>​        function  函数名（$形参1，$形参2， …… ）{ //形参，就是形式参数，是变量</p>
<p>​                函数体语句块；  //就是若干行代码</p>
<p>}</p>
<p><strong>调用语法形式：</strong></p>
<p>​        函数名（$实参1，$实参2， …… ）；   //实参就是实际参数，是数据</p>
<p><strong>说明</strong>：</p>
<ol>
<li><p>函数名的命名规则，跟变量名一样；</p>
</li>
<li><p>定义函数的目的就是为了以后能够调用；</p>
</li>
<li><p>调用函数，其实就是执行函数中代码；</p>
</li>
<li><p>形参，其实就是变量，是只能在该函数内部使用的变量；</p>
</li>
<li><p>实参，其实就是数据，是会传入函数内部的数据（==是一一对应地赋值给形参变量==）；</p>
</li>
</ol>
<h2 id="函数执行原理（重点-难点）"><a href="#函数执行原理（重点-难点）" class="headerlink" title="==函数执行原理（重点/难点）=="></a>==函数执行原理（重点/难点）==</h2><p>程序总是运行在一个“内存空间”。</p>
<p>程序开始执行的位置所在的空间，可以称之为“<strong>主运行空间</strong>”。</p>
<p>实际上，通常函数外面的那些程序，都是运行在主空间中。</p>
<p>那么，函数的运行，就相对独立了——==每个函数的每次调用，都是运行在单独的一个自己的空间中==。</p>
<p>如下所示：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527155526.png" alt="" loading="lazy"></p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="==函数参数=="></a>==函数参数==</h2><p><strong>形参（形式参数）</strong></p>
<p>​        就是定义函数的时候，在函数名后的小括号中给出的变量名。</p>
<p>​        形参，只能在函数内部使用——即该变量的使用范围仅仅局限于当前函数内部。</p>
<p>​        形参的本质是变量！</p>
<p><strong>实参（实际参数）</strong></p>
<p>​        就是调用函数的时候，在函数名后的小括号中给出的数据值。</p>
<p>​        实参的本质是数据！</p>
<p><strong>函数参数的传值方式</strong></p>
<p>含义：</p>
<p>​        实参变量的值，以什么方式传给形参。</p>
<p>说明：</p>
<p>​        其前提是：实参是一个变量的情况。</p>
<p>​        所以其实这里讨论的是：两个变量的传值方式问题。</p>
<p>​        默认情况下是值传递。</p>
<p>==可以使用“&amp;”符号设定为引用传递，形式如下：==</p>
<p>function f1( $p1, &amp;$p2, …. ）{ </p>
<p>。。。。。</p>
<p>}</p>
<p>此时，在函数内部，对该形参变量改变其值，则对应的实参变量（在函数外部）的值也改变了。</p>
<p><strong>形参的默认值</strong></p>
<p>形参可以设定默认值。形式为：$形参名 = 某值。</p>
<p>设定默认值的形参，只能放在没有设定默认值的形参的后面（右边）。</p>
<p>设定了默认值的形参对应的实参可以不提供数据，此时函数就会使用该默认值当做实参的值。</p>
<p>function f1($p1, ​$p2, ​$p3 = 3, $p4 =true ){</p>
<p>​        //函数体语句块</p>
<p>}</p>
<p>则此时调用上述函数，以下形式都可以：</p>
<p>f1(1,2);</p>
<p>f1(3, 4, 5);</p>
<p>f1(6,7,8, 9);</p>
<h2 id="函数返回值（重点"><a href="#函数返回值（重点" class="headerlink" title="函数返回值（重点)"></a>函数返回值（重点)</h2><p>含义：</p>
<p>​        一个函数在执行结束时，可以让其返回==一个==数据，这就是函数的返回值。</p>
<p>语法：</p>
<p>​        ==return 要返回的数据；==</p>
<p>说明：</p>
<ol>
<li><p>一般情况下一个函数执行结束都是需要返回一个数据值的。</p>
</li>
<li><p>函数也可以在执行的中途返回数据，此时，函数也是结束了的。</p>
</li>
<li><p>==一个函数执行得到的返回值，可以在任何需要数据的场合使用，跟使用一个变量数据一样。==</p>
</li>
</ol>
<h2 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h2><p>含义：</p>
<p>​        所谓可变函数，就是函数名是一个变量的情形。</p>
<p>​        可变函数实际上就是==在调用函数的时候，使用一个变量来表示函数名，并用该变量去调用函数。==</p>
<p>​        ==注意：定义函数的时候，不可以使用可变函数名!==</p>
<p>对比：</p>
<p>​        可变变量，就是变量名是一个变量，比如：$$v1;  </p>
<p>​        可变函数，就是函数名是一个变量，比如：</p>
<p>​                调用函数f1的语法是这样：f1();</p>
<p>​                可以使用可变函数的语法来调用：$func_name = “f1”; $func_name();   //此时实际就是调用f1</p>
<p>可变函数的本质是：一个变量的内容是一个字符串，该字符串是一个函数的名字，比如：</p>
<p>​        function f1(){ ……. }</p>
<p>​        function f2(){ ……. }</p>
<p>​        $f = “f1”;</p>
<p>​        <strong>$f();     //调用了函数f1，这就是可变函数！！</strong></p>
<p>​        $f = “f2”;</p>
<p>​        <strong>$f();     //调用了函数f2，这就是可变函数！！</strong></p>
<p>​        $f = “f3”;</p>
<p>​        $f();     //报错！因为没有f3这个函数</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>含义：</p>
<p>​        就是一个“定义时没有名字”的函数。</p>
<p>此时，就面临一个问题，那就是：没有名字，怎么调用呢？</p>
<p>实际上，此时它通过另一个方式来调用，如下所示：</p>
<p>​        $f1 = function  (形参…) { …….  }     //这是定义匿名函数的形式。</p>
<p>​        $f1(实参);   //这就是调用该调用。可见其调用，跟可变函数的写法非常类似。</p>
<h2 id="系统常用函数介绍"><a href="#系统常用函数介绍" class="headerlink" title="系统常用函数介绍"></a>系统常用函数介绍</h2><p>PHP语言，以函数极大丰富而闻名于世。</p>
<p>看手册，查手册，并作为一种学习的习惯：</p>
<p><strong>跟函数有关的函数</strong></p>
<p>​    function_exists(“函数名”)：判断一个函数是否已经存在；</p>
<p>​    func_get_arg( $n )： 在函数内部可用，用于获得第n个实参（n从0开始算起）</p>
<p>​    func_get_args()：   在函数内部可用，用于获得所有实参，结果是一个数组</p>
<p>​    func_num_args()：  在函数内部可用，用于获得实参的个数</p>
<p>上面3个函数，可以让我们在自定义的函数内部，直接访问（使用）实参数据，而不依赖于形参变量。</p>
<p>这种特性，可以给我们定义某种“不确定有几个数据需要计算的”场合。</p>
<p><strong>字符串有关常用函数</strong></p>
<p>输出与格式化：echo , print, printf, print_r, var_dump.</p>
<p>字符串去除与填充：trim, ltrim, rtrim, str_pad</p>
<p>字符串连接与分割：implode, join， explode, str_split</p>
<p>字符串截取：substr, strchr, strrchr,</p>
<p>字符串替换：str_replace, substr_replace</p>
<p>字符串长度与位置： strlen, strpos, strrpos,</p>
<p>字符转换：strtolower, strtoupper, lcfirst, ucfirst, ucwords</p>
<p>特殊字符处理：nl2br, addslashes, htmlspecialchars, htmlspecialchars_decode,</p>
<p><strong>==常用数学函数（重点)==</strong></p>
<p>max：   取得若干个数据中的最大值</p>
<p>min：   取得若干个数据中的最小值</p>
<p>round： 对某个数据进行四舍五入（可以设定保留几位小数）</p>
<p>ceil：   对某个数“向上取整”：将一个数据往上找出其小的一个整数（含其本身）。</p>
<p>floor：  对某个数“向下取整”：将一个数据往下找出其大的一个整数（含其本身）</p>
<p>​        $n1 = floor(4.1);  //4</p>
<p>​        $n2 = floor(4.9);  //4</p>
<p>​        $n3 = floor(4);     //4</p>
<p>​        $n4 = floor(-4.1);  //-5</p>
<p>abs：   取得某个数据的绝对值</p>
<p>sqrt：   计算某个数的开方值</p>
<p>pow：   对某个数进行“幂运算”（就是获得某个数的若干次方）</p>
<p>​        $n1 = pow(3, 2);  //3的2次方,9</p>
<p>​        $n2 = pow(2, 3);  //8</p>
<p>​        $n3 = pow(1.5, 2); //2.25</p>
<p>​        $n4 = pow(1.5, 2.5);   //。。。。。1.5的2.5次方</p>
<p>​        $n5 = pow(9, 0.5);     //3，就是开方，相当于sqrt()</p>
<p>rand：  获得某两个数之间的随机整数（含该两个数）</p>
<p>mt_rand: 获得某两个数之间的随机整数（含该两个数），比rand更快。</p>
<p>​        $n1 = mt_rand(0, 10);  //随机数在0-10之间（含）</p>
<p><strong>常用时间函数</strong></p>
<p>​    <strong>time</strong>：获得当前时间（精确到秒），结果其实一个“整数”而已，代表从1970年1月1日0:0:0秒到当前时刻的秒数。</p>
<p>​    <strong>microtime</strong>：获得当前时间（可以精确到微秒）</p>
<p>​    mktime：创建一个时间数据，参数为：时、分、秒，月、日、年</p>
<p>​    date：将一个时间转换为某种字符串形式</p>
<p>​    idate：取得一个时间的某个单项数据值，比如idate(“Y”)取得年份数</p>
<p>​    strtotime：将一个字符串“转换”为时间值；</p>
<p>​    date_default_timezone_set：在代码中设置“时区”</p>
<p>​    date_default_timezone_get：在代码中获取“时区”</p>
<h1 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h1><h2 id="变量的作用域问题"><a href="#变量的作用域问题" class="headerlink" title="变量的作用域问题"></a>变量的作用域问题</h2><p>简单来说，有3种作用域：局部作用域，全局作用域，超全局作用域；</p>
<p>相对应的，有3种变量：  局部变量，  全局变量，  超全局变量；</p>
<p><strong>局部作用域与局部变量：</strong></p>
<p>​        就是函数内部范围的作用域，其中定义的变量就是局部变量（包括形参也是局部变量）。</p>
<p>​        局部变量只能在其所在的局部作用域中使用（访问）。</p>
<p>​        局部变量在函数调用结束时，会被自动销毁（可以理解为函数执行结束，该执行空间也被销毁了）。</p>
<p>​        $v1 = 1;</p>
<p>​        function f1( $p1 , $p2 ){    //此函数范围就是一个局部作用域，其中有3个局部变量：$p1, $p2, $v2</p>
<p>​                $v2 = 2;</p>
<p>​                echo $ v1;      ==//报错！变量未定义==</p>
<p>​                echo $v2;</p>
<p>​            }</p>
<p>​            f1(); //</p>
<p>​            echo $v1;</p>
<p>​            echo $v2;   ==//报错！变量未定义==</p>
<p><strong>静态变量：一个特殊的局部变量</strong></p>
<p>含义：</p>
<p>​        在函数内部，使用static关键字修饰的变量。</p>
<p>形式：</p>
<p>​            function XXX( …. ){</p>
<p>​                    static $s1 = 10;      //此时，$s1就是静态变量</p>
<p>​                        ……</p>
<p>​                    }</p>
<p>==静态变量的特点：==</p>
<p>​        ==静态变量的值不会在函数调用结束时被销毁，而是会一直保留。==</p>
<p>​        ==也就是说，当再次调用函数时，该变量（的值）还能继续使用。==</p>
<p><strong>全局作用域与全局变量</strong></p>
<p>​        就是函数外部范围的作用域，其中定义的变量就是全局变量。</p>
<p>​        全局变量只能在其所在的全局作用域中可以直接使用（访问）。</p>
<p><strong>超全局作用域与超全局变量</strong></p>
<p>​        包括局部作用域和全局作用域的的整个作用域范围。</p>
<p>​        超全局变量可以在所有范围中使用（访问）。</p>
<p>​        实际上，只有有限的10来个系统预定义变量是超全局变量，包括：$_GET, $_POST, $_REQUEST等。</p>
<p>​        所以，系统预定义变量，也被统称为超全局变量。</p>
<p>PHP中的不同作用域的图示：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527164611.png" alt="" loading="lazy"></p>
<p><strong>一个特别的超全局变量：$GLOBALS</strong></p>
<p>​        它也是一个数组，==其中存储了我们自己定义的所有全局变量。==</p>
<p>​        每个全局变量的变量名，就是$GLOBALS数组的一个单元。</p>
<p>​        比如：</p>
<p>​                在全局作用域中定义如下变量：</p>
<p>​                $v1 = 1;         //这一行执行，就有了一个这个：$GLOBALS[‘v1’], 其值为1</p>
<p>​                $v2 = ‘abc’;      //这一行执行，就有了一个这个：$GLOBALS[‘v2’], 其值为’abc’</p>
<p>​                $v3 = true;       //这一行执行，就有了一个这个：$GLOBALS[‘v3’], 其值为true</p>
<p>它可以让我们在局部作用域范围中，使用全局变量，方式如下：</p>
<p>​        $v1 = 10;     //全局变量</p>
<p>​        function func1( ){</p>
<p>​                echo $GLOBALS[‘v1’];   //输出10；</p>
<p>​            echo $v1;               //报错：变量v1未定义</p>
<p>​            $s1 = $GLOBALS[‘v1’] * 5; //结果为50；</p>
<p>​            $s2 = $v1 * 5;             //报错：变量v1未定义</p>
<p>}</p>
<p><strong>一个特别的的关键字：global</strong></p>
<p>作用：</p>
<p>​        用于在局部作用域中，修饰一个跟全局变量同名的局部变量。</p>
<p>​        此时该局部变量也可以使用全局变量的值了——实际上他们其实是类似变量引用关系。</p>
<h2 id="递归函数（重点-难点"><a href="#递归函数（重点-难点" class="headerlink" title="递归函数（重点/难点)"></a>递归函数（重点/难点)</h2><p>基本含义：</p>
<p>​        就是一个函数内部再调用该函数本身的一种情形，这是语法形式上的。</p>
<p>​        具体场景是：</p>
<p>​                如果要解决的“最终问题”，可以根据比该问题“小一级”的问题的答案而得到解决，</p>
<p>​                并且，该“小一级”的问题，还可以根据比其“更小一级”的问题的答案而得到解决，</p>
<p>​                以此类推，直到“最小一级”的问题。如果最小一级问题已知，则最终的问题也就解决了。</p>
<p><strong>==危险：==</strong></p>
<p>​        ==如果函数在执行的过程中没有一个“不再调用”的终结机制，那么就会出现“停不下来”的现象。==</p>
<p>原理：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527165100.png" alt="" loading="lazy"></p>
<p><strong>递归调用过程的代码演示：</strong></p>
<p>分析一下代码的输出结果：</p>
<p>​        function f1($n){</p>
<p>​                $n++;</p>
<p>​                echo “$n “;</p>
<p>​                if($n &lt; 5){</p>
<p>​                        f1($n);</p>
<p>​                }</p>
<p>​            echo “$n “;</p>
<p>​                }</p>
<p>​            f1(1);</p>
<h1 id="文件加载"><a href="#文件加载" class="headerlink" title="文件加载"></a>文件加载</h1><h2 id="文件加载的含义"><a href="#文件加载的含义" class="headerlink" title="文件加载的含义"></a>文件加载的含义</h2><p>含义：</p>
<p>​        ==将一个（别的）文件包含到当前文件中，成为当前文件运行过程中的一部分。==</p>
<p>​        通常，一些公共的代码，在多个页面都需要用到的时候，会做成一个独立的文件。</p>
<p>​        然后在不同的页面需要用到的时候，直接载入进来就可以了。</p>
<p>语法：</p>
<p>​        ==include “要载入的文件路径”;      //可以是相对路径，或本地物理路径。==</p>
<p>说明：</p>
<p>​        可以载入php文件，也可以载入html文件。</p>
<p>原理：</p>
<p>​        载入一个文件的本质是：将被载入的文件“插入”到当前载入代码所在的位置。</p>
<h2 id="文件加载的四种方式（重点"><a href="#文件加载的四种方式（重点" class="headerlink" title="==文件加载的四种方式（重点)=="></a>==文件加载的四种方式（重点)==</h2><p>四种方式如下所示：</p>
<p>​        include ‘要加载的文件’；</p>
<p>​        include_once  ‘要加载的文件’；</p>
<p>​        require   ‘要加载的文件’；</p>
<p>​        require_once ‘要加载的文件’；</p>
<p>==获取物理路径（绝对路径）的方式：==</p>
<p>​        ==__DIR__：表示当前文件所在路径，由它可以构建出绝对路径；==</p>
<p>​        ==getcwd()：表示当前正访问的网页路径，由它也可以构建出绝对路径；==</p>
<p>非相对非绝对路径（其实就是没有给出路径，只给出文件名）：不推荐！</p>
<p>​        形式为：  include ‘文件名’；</p>
<p>​        此时，会按如下顺序去寻找该文件：</p>
<p>​            1. 先在php.ini中include_path项设定的目录中寻找该文件；</p>
<p>​            2. 如果上一步没有找到，就在当前工作目录（由getcwd()获取）下寻找该文件；</p>
<p>​            3. 如果上一步没有找到，就在当前载入语句的文件所在目录（由<strong>DIR</strong>获取）下寻找；</p>
<p>​            4. 如果上一步还是没有找到，就报错了。        </p>
<h2 id="四种方式的区别"><a href="#四种方式的区别" class="headerlink" title="四种方式的区别"></a>四种方式的区别</h2><p>include：每次都载入文件（可能会重复载入），如果载入失败，在报错后继续执行后续语句；</p>
<p>include_once：只载入一次（不会重复载入），如果载入失败，在报错后继续执行后续语句；</p>
<p>require：每次都载入文件（可能会重复载入），如果载入失败，在报错后终止程序；</p>
<p>require_once：只载入一次（不会重复载入），如果载入失败，在报错后终止程序；</p>
<p>一般来说，如果被载入的文件内容，是后续代码运行的必备前提，则应该使用require载入。</p>
<p>如果被载入的文件内容，只需要（或只允许）出现一次，则应该使用”xxxx_once”载入。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h2><p>语法错误：</p>
<p>​        程序不能运行，是在运行之前，检查语法的时候，就发现语法出错，结果是提示错误，不运行程序。</p>
<p>运行时错误：</p>
<p>​        语法检查没错，然后开始运行，在运行中出现了错误，然后报错。</p>
<p>​        这是开发中最常见的错误。</p>
<p>​     </p>
<p>逻辑错误：</p>
<p>​        程序能运行，且一直到结束没有报错，但执行得到的结果却是错的。</p>
<h2 id="常见错误代号（重点）"><a href="#常见错误代号（重点）" class="headerlink" title="常见错误代号（重点）"></a>常见错误代号（重点）</h2><p>含义：</p>
<p>​        是指在程序运行时，发生的错误，系统会针对每种错误，给出相应的错误代号，并进行提示（报错）。</p>
<p>​        另外，程序如果在运行之前检查语法的时候就发现语法错误，也会报错，也有一个错误代号。</p>
<p>常见错误代号有：</p>
<p>​        E_NOTICE：</p>
<p>​            提示性错误，轻微；</p>
<p>​            错误发生后，后面的程序继续执行。</p>
<p>​        E_WARNING：</p>
<p>​            警告性错误，稍微严重；</p>
<p>​            错误发生后，后面的程序继续执行。</p>
<p>​        E_ERROR：</p>
<p>​            严重错误/致命错误；</p>
<p>​            错误发生后，后面的程序不再执行！</p>
<p>​        E_PARSE：</p>
<p>​            语法错误（语法解析错误）；</p>
<p>​            语法解释错误，是直接就不运行程序。</p>
<p>​        E_USER_NOTICE：</p>
<p>​            用户自定义的提示错误</p>
<p>​        E_USER_WARNING：</p>
<p>​            用户自定义的警告错误</p>
<p>​        E_USER_ERROR：</p>
<p>​            用户自定义的严重错误</p>
<p>​        E_ALL：</p>
<p>​            它是一个代表“所有”错误的代号。</p>
<p>说明：</p>
<ol>
<li><p>这些错误代号，其实只是系统预先设定的一些常量，他们的值大约是：1， 2， 4， 8， 16…..</p>
</li>
<li><p>这些错误代号，通常只是用于对错误控制时进行“设置”使用。</p>
</li>
<li><p>他们是一系列的整数，并具有一定的规律：1,2,4,8,16,32,64， 。。。。</p>
</li>
<li><p>可以在php.ini中使用（设置）他们，如下所示：</p>
</li>
</ol>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527170446.png" alt="" loading="lazy"></p>
<h2 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h2><p>就是发生了一个错误的意思——即触发了错误。</p>
<p>有两种情形会触发错误：</p>
<p>​        1. 程序本身有错，则运行时就会触发错误（并提示）。</p>
<p>​        2. 程序本身没错，但出现不符合预计的情形（比如数据不符合要求）。</p>
<p>​            此时程序员可以主动触发一个错误，也可以说是由程序员“主动创建一个错误”</p>
<p>​            ——这就是“用户错误”，包括：</p>
<p>​                    E_USER_NOTICE：</p>
<p>​                    E_USER_WARNING：</p>
<p>​                    E_USER_ERROR：</p>
<p>如何触发“用户错误”呢？</p>
<p>自定义错误触发语法：</p>
<p>​            trigger_error(“自定义错误提示内容”, 自定义错误的代号);</p>
<h2 id="错误显示设置"><a href="#错误显示设置" class="headerlink" title="错误显示设置"></a>错误显示设置</h2><p>如果有错误发生（触发了错误），==默认情况下会被显示在页面==（即输出的结果页面）。</p>
<p>我们可以对此进行设置，以决定以下两点：</p>
<p>​        1. 设置display_errors以决定是否显示错误：</p>
<p>​                    在php.ini中设置：   display_errors = On或Off</p>
<p>​                            这里设置，影响所有使用该php语言引擎的代码（网站页面）；</p>
<p>​                    在php文件中设置：  ini_set(‘display_errors’, 1或0);  //1表示显示，0不显示</p>
<p>​                            在这里设置，只影响当前网页代码本身。</p>
<p>​        2. 设置error_reporting以决定显示哪些错误：</p>
<p>​                    在php.ini中设置：   error_reporting = 错误代号1 | 错误代号2 | ….. </p>
<p>​                            //(要显示的就写出来，或者可以写E_ALL, 表示显示所有）</p>
<p>​                            在代php文件中，道理类似：ini_set(‘error_reporting’, 错误代号1 | 错误代号2 | …..）</p>
<h2 id="错误日志设置"><a href="#错误日志设置" class="headerlink" title="错误日志设置"></a>错误日志设置</h2><p>如果有错误发生（触发了错误），默认情况下不会将错误信息记录（保存）下来。</p>
<p>我们可以对此进行设置，以决定以下两点：</p>
<p>​        1. 设置log_errors以决定是否记录错误：</p>
<p>​                    php.ini中设置：   log_errors = On 或 Off</p>
<p>​                    代码文件中设置： ini_set (‘log_errors’, 1或0)</p>
<p>​        2. 设置error_log以决定记录到哪里：</p>
<p>​                    通常，就设置为一个文件名，php系统会在网站的每个文件夹下都建立该文件，并记录错误。</p>
<p>​                    php.ini中： error_log = error.txt;     //它是纯文本的</p>
<p>​                    代码中： ini_set(“error_log”, ‘error.txt’);</p>
<h2 id="自定义错误处理（重点-难点"><a href="#自定义错误处理（重点-难点" class="headerlink" title="==自定义错误处理（重点/难点)=="></a>==自定义错误处理（重点/难点)==</h2><p>之前，我们面对的情形都是错误发生的时候，系统生成错误，并处理错误（给出错误信息）。</p>
<p>我们能控制的就只是：是否显示，显示什么，是否记录，记录到哪里？</p>
<p>实际上，我们也可以更进一步控制错误信息，以决定错误发生的时候，显示什么样的错误信息。</p>
<p>这就是“自定义错误处理”。</p>
<p>具体做法，分2步：</p>
<p>​        第1步：</p>
<p>​            声明错误发生时，由我们自己来处理——设定一个错误处理的函数名。</p>
<p>​        第2步：</p>
<p>​            定义该函数，在函数中详细设定错误的处理情况：怎么显示，显示什么，怎么记录，记录什么。</p>
<h1 id="字符串详解"><a href="#字符串详解" class="headerlink" title="字符串详解"></a>字符串详解</h1><h2 id="4种不同形式的字符串"><a href="#4种不同形式的字符串" class="headerlink" title="4种不同形式的字符串"></a>4种不同形式的字符串</h2><p><strong>单引号字符串</strong></p>
<p>​        形式：  $s1 = ‘字符串内容’</p>
<p>​        特点：</p>
<p>​                只能使用2个转义符： \\（代表一个反斜杠） \’（代表一个单引号）</p>
<p>​        ==通常，如果没有其他特殊需求（比如字符串中使用一些转义符，以及一些变量），则推荐使用单引号字符串。！==</p>
<p><strong>双引号字符串</strong></p>
<p>形式： $s1 = “字符串内容”</p>
<p>特点：</p>
<p>​    1. 能使用较为丰富的转义符，包括：\  \”   \n  \r   \t   $等</p>
<p>​            \n  ：代表“换行符”（就是一个新行）</p>
<p>​            \r   ：代表“回车符”（其实也是一个新行）</p>
<p>​            \t   ：代表“tab符”，</p>
<p>​            $  ：代表“$”本身，因为双引号字符串中能识别（解析）变量，则如果不想要去解析，就用此转义！</p>
<p>​            $v1 = 10;</p>
<p>​            echo “结果为：$v1”; //输出内容为： 结果为：10</p>
<p>​            echo “结果为：$v1”; //输出内容为： 结果为：$v1</p>
<p>​        2. “$”符号在其中会被识别为是变量的起始符号，并试图读取变量值——即能识别变量；</p>
<p>​        3. 识别其中变量，建议使用大括号括起来，类似这样：{$变量名}， {$数组[‘下标’]}</p>
<p><strong>heredoc字符串</strong></p>
<p>形式：$s1 = &lt;&lt;&lt;==“标识符”==</p>
<p>这里写字符内容，可以多行写</p>
<p>标识符;</p>
<p>特点：</p>
<p>​    1. 特点跟双引号字符串一样！</p>
<p>注意：</p>
<p>​    ==标识符结束那一行，只能出现标识符及紧挨着的分号，任何其他字符都不可以出现。==</p>
<p><strong>nowdoc字符串</strong></p>
<p>形式：$s1 = &lt;&lt;&lt;==‘标识符’==</p>
<p>这里写字符内容，可以多行写</p>
<p>标识符;</p>
<p>特点：无特点，是最“纯净”的字符串，写什么就是什么。</p>
<p>heredoc字符串，和nowdoc字符串，适用于表达（描述）一大段内容的字符串，特别是适合于写html部分的代码（含js，css等）。</p>
<p>如下：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527172348.png" alt="" loading="lazy"></p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>转义的字符的本质，其实是在一个字符串的语法形式中，如何来表达一些相对特殊的一些字符的问题。</p>
<p>比如：</p>
<p>​        双引号字符串：$s = “这里字符串内容，要是直接出现双引号就会有语法问题。”</p>
<h2 id="字符串的长度问题"><a href="#字符串的长度问题" class="headerlink" title="字符串的长度问题"></a>字符串的长度问题</h2><p>字符串的长度问题，有两个方面的理解：</p>
<ol>
<li><p>一个字符串有几个字符（人可见到的字符个数）；</p>
</li>
<li><p>一个字符串占据多少个字节空间（人不可见）；</p>
</li>
</ol>
<p><strong>几个常识：</strong></p>
<p>​    ==a，1字节（B）就是8个bit位（最小的存储空间），1KB=1024B，1MB=1024KB，1GB=1024MB。。==</p>
<p>​    ==b，一个英文字符占据1字节空间，gbk编码中1个汉字占据2个字节，utf8编码1个汉字占3字节。==</p>
<p>求php字符串的长度，，有两个函数：</p>
<p>​        strlen(字符串)：</p>
<p>​            求该字符串的“字节数”，也就是占据的字节空间大小；</p>
<p>​        mb_strlen(字符串)：</p>
<p>​            求该字符串的“字符个数”。</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527172832.png" alt="" loading="lazy"></p>
<p>该模块准确的位置如下：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527172857.png" alt="" loading="lazy"></p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527172913.png" alt="" loading="lazy"></p>
<h2 id="常用字符串函数（重点"><a href="#常用字符串函数（重点" class="headerlink" title="常用字符串函数（重点)"></a>常用字符串函数（重点)</h2><p>字符串输出：</p>
<p>​        echo： 输出一个或多个字符（不是函数，是语言结构）</p>
<p>​        print：输出一个字符串</p>
<p>​        print_r：输出变量的较为详细的信息</p>
<p>​        var_dump：输出变量的完整信息</p>
<p>字符串去除与填充：</p>
<p>​        trim：消除一个字符串两端的空白字符或指定字符（空白字符包括：空格，\n, \r, \t等）</p>
<p>​        ltrim：消除一个字符串左边的空白字符或指定字符</p>
<p>​        rtrim：消除一个字符串右边的空白字符或指定字符</p>
<p>​        str_pad：将一个字符串使用指定的字符填充到指定的长度</p>
<p>字符串连接与分割：</p>
<p>​        implode：将一个数组的值连接起来组成一个字符串</p>
<p>​        join：同implode</p>
<p>​        explode： 将一个字符串使用指定的字符分割为一个数组</p>
<p>​        str_split：将一个字符串按指定的长度分割为一个数组</p>
<p>字符串截取：</p>
<p>​        substr：获取一个字符串中指定位置开始指定长度的子字符串</p>
<p>​        strstr：获取一个字符串中某个指定字符首次出现的位置起，到最后结尾处的字符<br>​                strstr(‘abcd.12.3.txt’, ‘.’);   //结果是：”.12.3.txt”</p>
<p>​        strrchr：获取一个字符串中某个指定字符最后一次出现的位置起，到最后结尾处的字符<br>​                strrchr(‘abcd.12.3.txt’, ‘.’);  //结果是：”.txt”</p>
<p>字符串替换：</p>
<p>​        str_replace：将一个字符串中的指定字符，替换为给定的新字符。</p>
<p>​        substr_replace：将一个字符串中指定位置开始的指定个数的字符，替换为给定的新字符。</p>
<p>字符串长度与位置： </p>
<p>​        strlen：获取字符串的字节长度。</p>
<p>​        strpos：获取一个字符串中某个子字符串首次出现的位置。<br>                strpos(‘abcd.12.3.txt’, ‘.’);  //结果是：4</p>
<p>​        strrpos：获取一个字符串中某个子字符串最后一次出现的位置。</p>
<p>​                strrpos(‘abcd.12.3.txt’, ‘.’);  //结果是：9</p>
<p>​                strrpos(‘abcd.12.3.txt’, ‘cd’); //结果是：2</p>
<p>字符转换：</p>
<p>​        strtolower：将一个字符串转换为小写。</p>
<p>​        strtoupper：将一个字符串转换为大写。</p>
<p>​        lcfirst：将一个字符串的首字母转换为小写。</p>
<p>​        ucfirst：将一个字符串的首字母转换为大写。</p>
<p>​        ucwords：将一个字符串中的所有单词的首字母转换大写。</p>
<p>特殊字符处理：</p>
<p>​        nl2br：将换行符转换为”<code>&lt;br /&gt;</code>”标签字符</p>
<p>​        addslashes： 将一个字符串中的以下几个字符使用反斜杠进行转义：\    ‘   “   </p>
<p>​        htmlspecialchars：将html中的特殊字符转换为html实体字符，如下所示： </p>
<p>​            （&amp; ‘ “ &lt; &gt; ）分别转换为：（（&amp; &apos; &quot; &lt; &gt; ）</p>
<p>​        htmlspecialchars_decode：将html实体字符，转换回原本的字符。</p>
<p>案例：</p>
<p>​        取出如下若干个文件中的图片文件。</p>
<p>​        $files = array(‘abc.gif’, ‘123.txt’, ‘dir1/gift.PNG’, ‘file1.JPG’, ‘gif动画制作教程.doc’ );</p>
<h1 id="数组详解"><a href="#数组详解" class="headerlink" title="数组详解"></a>数组详解</h1><h2 id="数组的概念和定义"><a href="#数组的概念和定义" class="headerlink" title="数组的概念和定义"></a>数组的概念和定义</h2><p>==数组，是指将若干数据按一定的顺序组合为一个整体。==</p>
<p>每个数据被称为一个“单元”——数组单元。</p>
<p>每个单元由两部分构成：下标和值，下标也称为“键”（key），</p>
<p>数组的一个重要特点是：其中的数据有明确的顺序，而是，是其放入数组时的先后顺序。</p>
<p>数组有如下几种定义形式：</p>
<p>形式1：</p>
<p>​        $arr1 = array(单元1，单元2，…）；</p>
<p>形式2：</p>
<p>​        $arr2 = [单元1，单元2，…]；</p>
<p>​        单元（元素）的形式为： [下标=&gt;]值</p>
<p>形式3：（不推荐）</p>
<p>​        $arr3[下标1] = 值1；</p>
<p>​        $arr3[下标2] = 值2；</p>
<p>数据取值的语法形式：</p>
<p>​        $数组名[下标];       //其中，下标可以是整数的，也可以是字符串的（注意有引号）</p>
<h2 id="数组下标问题"><a href="#数组下标问题" class="headerlink" title="数组下标问题"></a>数组下标问题</h2><p><strong>下标的可用值</strong></p>
<p>​        可以使用整数或字符串。</p>
<p><strong>整数下标的特性</strong></p>
<p>​        可以使用任意整数，也可以不显式使用下标，此时默认就是整数下标。</p>
<p>​        而且，从前往后，每一个没有使用下标的单元，系统给其分配的下标为之前所用过的整数下标的最大值+1（对于第一个是0）。</p>
<p>​        $arr1 = array(‘a’, 2=&gt;’b’, ‘c’, ‘x’=&gt;’d’, ‘e’);  // 其下标分别为：0, 2, 3, ‘x’, 4</p>
<p>​        $arr2 = array(5=&gt;‘a’, 2=&gt;’b’, ‘c’, ‘x’=&gt;’d’);    // 其下标分别为：5, 2, 6, ‘x’</p>
<p>​        $arr3[‘x’] = 5;     //这一行，会自动创建一个数组，</p>
<p>​        $arr3[ ]  = 6;     //此时下标就是0</p>
<p><strong>索引数组</strong></p>
<p>通常是指一个数组的下标是从0开始的连续的整数。</p>
<p>举例1：</p>
<p>​        $arr1 = array(5, 8, 12, 2, 3);</p>
<p>​        $arr2 = [8, 22, 24, 22, 12];</p>
<p>​        $arr3[ ] = 8;</p>
<p>​        $arr3[ ] = 24;</p>
<p>​        $arr3[ ] = 22;</p>
<p><strong>关联数组</strong></p>
<p>通常是指一个数组的下标都是字符串。</p>
<p>​        $person = array(</p>
<p>​                ‘name’=&gt;’张三’， </p>
<p>​                ‘age’=&gt;18, </p>
<p>​                ‘edu’=&gt; ‘大学’, </p>
<p>​                ‘salary’=&gt;10000, </p>
<p>​                ‘from’=&gt;’北京’,</p>
<p>​        );</p>
<h2 id="PHP数组的维数"><a href="#PHP数组的维数" class="headerlink" title="PHP数组的维数"></a>PHP数组的维数</h2><p>按通常的数组元素的复杂程度，数组可以分为一维数组，二维数组，三维数组等等</p>
<p>一维数组：</p>
<p>数组的每一个单元的值都是一个“非数组”值。</p>
<p>$arr1 = array(11, 12, 13, 14);</p>
<p>二维数组：</p>
<p>数组的每个单元的值都是一个“一维数组”。</p>
<p>$arr2 = array(</p>
<p>array(11, 12, 13),</p>
<p>array(21, 22, 23),</p>
<p>…..</p>
<p>);</p>
<p>三维数组：</p>
<p>数组的每个单元的值都是一个“二维数组”。</p>
<p>多维数组：</p>
<p>依此类推。。。。</p>
<p>不整齐数组（异形数组）：</p>
<p>实际上，由于PHP的数组值可以是“任意数据”，因此，PHP数组的维数其实没有太大实际意义的。</p>
<p>所谓维数，其实是另一些编程语言中的数组的“整齐”格式的说法：一维数组类似排成一排的格子（线）；二维数组类似排成一个平面的格子（面）；三维数组类似堆满了一屋子的格子（体）。</p>
<p>而php数组，却可以更为灵活，类似这样：</p>
<p>array(</p>
<p>1, 2, array(31, 32, ), 4,</p>
<p>array(51, 52, 53, array(541, 542, 543, 544) ), </p>
<p>6, array(71, 72, 73), </p>
<p>);</p>
<p>这种数组就不好说几维的了，而可以称为“异形数组。</p>
<h2 id="数组的遍历（重点）"><a href="#数组的遍历（重点）" class="headerlink" title="==数组的遍历（重点）=="></a>==数组的遍历（重点）==</h2><p><strong>使用foreach语句遍历数组</strong></p>
<p>遍历：就是对数组的每一项都“访问”到并进行所需要的数据处理。</p>
<p>foreach( $数组名 as [​$key =&gt;] $value){</p>
<p>​            //这里，$key和$value只是变量，它会在遍历数组的过程中，按顺序依次取得数组每个单元的下标和值。</p>
<p>echo “<code>&lt;br /&gt;</code>{$key} &gt;&gt;&gt; {$value} “;</p>
<p>}</p>
<p><strong>使用for循环语句遍历数组</strong></p>
<p>数组的指针：每一个数组内部，都有一个“指针”，正常情况下，指针指向数组的某个单元，起初默认是指向第一个单元。</p>
<p>对于数组 $arr1 = array( 18, 22, 13, 28, 15, 33, );</p>
<p>​                                    </p>
<table>
<thead>
<tr>
<th>下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>值</td>
<td>18</td>
<td>22</td>
<td>13</td>
<td>28</td>
<td>15</td>
<td>33</td>
</tr>
</tbody></table>
<p>初始状态下，指针指向数组的第一个单元。</p>
<p>php中，有如下几个函数，可以针对数组指针进行相应操作：</p>
<p>​        $re = current( $arr1);     //取得数组中当前指针所在单元的值；</p>
<p>​        $re = key( $arr1 );      //取得数组中当前指针所在单元的键（下标）；</p>
<p>​        $re = next( $arr1 );      //将数组中的指针往后移动一个位置，并取得新位置上的值；</p>
<p>​        $re = prev( $arr1 );      //将数组中的指针往前移动一个位置，并取得新位置上的值；</p>
<p>​        $re = end( $arr1 );      //将数组中的指针移动到最后一个位置，并取得新位置上的值；</p>
<p>​        $re = reset($arr1);      //将数组中的指针移动到最前一个位置，并取得新位置上的值；</p>
<h2 id="常用数组函数"><a href="#常用数组函数" class="headerlink" title="常用数组函数"></a>常用数组函数</h2><p>max()：     获取一个数组中的最大值</p>
<p>min()：      获取一个数组中的最小值</p>
<p>count()：     获取一个数组的元素个数</p>
<p>in_array()：  判断一个数据是否在指定数组中。</p>
<p>语法形式：$b = in_array( $数组， 数据); //结果true或false</p>
<p>range()：         生成某个范围的连续值的数组，比如range(3, 9)会得到数组：array(3, 4, 5, 6, 7, 8, 9, );</p>
<p>array_keys()：    取出一个数组中的所有“键”并放入一个索引数组中。</p>
<p>array_values()：  取出一个数组中的所有“值”并放入一个索引数组中。</p>
<p>array_push()：    将一个或多个数据放入一个数组的“末端”。</p>
<p>array_pop()：     将一个数组的最后一个单元删除，并返回该单元的值。</p>
<p>array_reverse()：  将一个数组的所有单元的顺序进行反转（最前的放最后，最后的放最前）</p>
<h2 id="数组排序算法（重点-难点）"><a href="#数组排序算法（重点-难点）" class="headerlink" title="==数组排序算法（重点/难点）=="></a>==数组排序算法（重点/难点）==</h2><p><strong>数组的排序问题</strong></p>
<p>常用的排序函数：sort, rsort, asort, arsort</p>
<p>数组排序函数大全：</p>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527184939.png" alt="" loading="lazy"></p>
<p><strong>冒泡排序算法</strong></p>
<p>原理：</p>
<p>​        遍历一个数组，在此过程中，将相邻的两个单元的值进行比较：如果前面的比后面的大，则将两个值交换位置。这个过程到最后，数组中的最大值一定放在最后位置了。</p>
<p>​        如果将上述过程再进行一遍，则又可以确定剩余数据中的最大值放在倒数第二的位置。</p>
<p>​        然后将上述过程继续进行一遍，则可以继续确定剩余数据中的最大值放在倒数第三的位置。</p>
<p>​        依次类推。。。。。。进行若干次，就排好了。</p>
<p>图示：</p>
<p>​        有数组：$arr1 = array(18, 22, 12,  15, 23, 9);</p>
<table>
<thead>
<tr>
<th>原始数组</th>
<th>18</th>
<th>22</th>
<th>12</th>
<th>15</th>
<th>23</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>第1趟之后</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>第2趟之后</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>第3趟之后</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>第4趟之后</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>第5趟之后</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>选择排序算法</strong></p>
<p>原理：</p>
<p>​        遍历一个数组，在此过程中，找出数组中的最大值及其位置。然后将该最大值的单元，跟数组的最后一个单元“交换位置”，这样进行一趟，数组中的最大值就一定放在最后位置了。</p>
<p>​        将上述过程中剩余的数据继续遍历一次，并做同样的事情，则此时剩余部分的最大值也能够放在剩余部分的最后位置——对整体而言就是倒数第二的位置。</p>
<p>​        依此类推。。。。。。。进行若干次，就排好了。</p>
<p>图示：</p>
<p>​        有数组：$arr1 = array(18, 22, 12,  15, 23, 9);</p>
<table>
<thead>
<tr>
<th>原始数组</th>
<th>18</th>
<th>22</th>
<th>12</th>
<th>15</th>
<th>23</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>第1趟之后</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>第2趟之后</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>第3趟之后</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>第4趟之后</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>第5趟之后</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527185140.png" alt="" loading="lazy"></p>
<h2 id="数组查找算法"><a href="#数组查找算法" class="headerlink" title="数组查找算法"></a>数组查找算法</h2><p>查找算法，就是从一个数组中，找一个“目标”（可以是值，也可以是键）的算法。</p>
<p>数组的查找函数：</p>
<p>​        in_array()         ：在一个数组中找是否存在某个数据。</p>
<p>​        array_search()     ： 在数组中搜索给定的值，如果成功则返回相应的键名</p>
<p>​        array_key_exists() ： 检查给定的键名或索引是否存在于数组中</p>
<p>一种查找算法：</p>
<p>遍历查找：不值得一提！</p>
<p><strong>二分查找</strong></p>
<p>此查找算法针对的数组有以下条件：</p>
<p>​        1. 索引数组；</p>
<p>​        2. 数组是已经排好序的了。</p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="https://gitee.com/ghat/blogimage/raw/master/img/20200406081241.png" target="_blank" rel="noopener"><img loading="lazy" src="https://gitee.com/ghat/blogimage/raw/master/img/20200406081241.png" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="https://gitee.com/ghat/blogimage/raw/master/img/20200406081332.png" target="_blank" rel="noopener"><img loading="lazy" src="https://gitee.com/ghat/blogimage/raw/master/img/20200406081332.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>ghatgy</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://yoursite.com/2020/05/28/PHP%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/" title="PHP基本语法规则">http://yoursite.com/2020/05/28/PHP%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless stating additionally.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/05/28/PHP%E8%BF%9E%E6%8E%A5MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="prev" title="PHP连接MySQL服务器"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">PHP连接MySQL服务器</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/04/06/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/" rel="next" title="SSRF-服务器端请求伪造"><span class="post-nav-text">SSRF-服务器端请求伪造</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div><div id="comment"><div class="comment-tooltip text-center"><span>若您无 GitHub 账号，可直接在下方匿名评论。</span><br><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" href="https://github.com/YunYouJun/yunyoujun.github.io/issues?q=is:issue+PHP基本语法规则" target="_blank" rel="noopener">GitHub Issues</a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> ghatgy</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v4.2.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v0.4.0</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2019-04-12T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>